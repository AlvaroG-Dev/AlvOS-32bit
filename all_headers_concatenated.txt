
================================================================================
FILE: terminal.h
================================================================================

#ifndef TERMINAL_H
#define TERMINAL_H

#include "drawing.h"
#include "keyboard.h"
#include "vfs.h"
#include <stdbool.h>

#define ANSI_COLOR_BLACK "\033[30m"
#define ANSI_COLOR_RED "\033[31m"
#define ANSI_COLOR_GREEN "\033[32m"
#define ANSI_COLOR_YELLOW "\033[33m"
#define ANSI_COLOR_BLUE "\033[34m"
#define ANSI_COLOR_MAGENTA "\033[35m"
#define ANSI_COLOR_CYAN "\033[36m"
#define ANSI_COLOR_WHITE "\033[37m"
#define ANSI_COLOR_RESET "\033[0m"

// Ahora estos valores se calculan dinÃ¡micamente
#define COMMAND_HISTORY_SIZE 10

// Buffer circular configuraciÃ³n - factores de cÃ¡lculo
#define BUFFER_LINE_MULTIPLIER                                                 \
  55 // Multiplicador para calcular lÃ­neas del buffer (55x mÃ¡s que visible)
#define MIN_BUFFER_LINES 1024 // MÃ­nimo nÃºmero de lÃ­neas en buffer
#define MAX_BUFFER_LINES 8192 // MÃ¡ximo nÃºmero de lÃ­neas en buffer

// Estados para el parser ANSI
typedef enum {
  ANSI_STATE_NORMAL,
  ANSI_STATE_ESCAPE,
  ANSI_STATE_CSI, // Control Sequence Introducer
  ANSI_STATE_OSC  // Operating System Command
} AnsiParserState;

// Estructura para el buffer circular
typedef struct {
  char *data;            // Buffer de caracteres
  uint32_t *line_attrs;  // Atributos por lÃ­nea (colores, flags)
  uint32_t *char_colors; // Colores por caracter (FG color)
  uint32_t size;         // TamaÃ±o total del buffer
  uint32_t lines;        // NÃºmero total de lÃ­neas
  uint32_t width;        // Ancho de cada lÃ­nea (caracteres por lÃ­nea)
  uint32_t head;         // PosiciÃ³n de escritura (lÃ­nea mÃ¡s reciente)
  uint32_t tail;         // PosiciÃ³n mÃ¡s antigua vÃ¡lida
  uint32_t count;        // NÃºmero de lÃ­neas vÃ¡lidas
  uint8_t wrapped;       // 1 si el buffer ha dado la vuelta
} CircularBuffer;

// Estructura para atributos de texto
typedef struct {
  uint32_t fg_color;
  uint32_t bg_color;
  uint8_t bold;
  uint8_t underline;
  uint8_t blink;
  uint8_t reverse;
  uint8_t conceal;
} TextAttributes;

// Estructura para informaciÃ³n del prompt
typedef struct {
  char username[32];
  char hostname[64];
  char current_dir[VFS_PATH_MAX];
  uint32_t last_exit_code;
  uint32_t job_count;
  uint8_t is_root;
  char time_format[32];
} PromptInfo;

typedef struct {
  CircularBuffer buffer; // Buffer circular principal

  // Dimensiones calculadas dinÃ¡micamente
  uint32_t width;  // Caracteres por fila
  uint32_t height; // Filas visibles en pantalla

  uint32_t cursor_x;
  uint32_t cursor_y;
  uint32_t view_offset;     // Offset de visualizaciÃ³n (para scroll)
  uint32_t view_start_line; // LÃ­nea de inicio en el buffer circular
  uint32_t fg_color;        // Color actual del texto
  uint32_t bg_color;        // Color actual del fondo
  uint32_t default_fg;      // Color por defecto del texto
  uint32_t default_bg;      // Color por defecto del fondo
  char input_buffer[256];
  uint32_t input_pos;
  char command_history[COMMAND_HISTORY_SIZE][256];
  uint32_t history_pos;
  uint32_t history_count;
  uint32_t current_history;
  uint8_t echo;
  uint8_t needs_full_redraw;
  uint8_t in_history_mode;
  char saved_input[256];
  uint8_t cursor_visible;
  uint32_t cursor_blink_rate;
  uint32_t last_blink_time;
  uint8_t cursor_state_changed;
  uint8_t *dirty_lines; // Array dinÃ¡mico de lÃ­neas sucias
  uint8_t flags;
  uint32_t current_fg_color; // Color actual del texto
  uint32_t current_bg_color; // Color actual del fondo
  uint8_t ansi_parser_state; // Estado del parser ANSI
  char ansi_buffer[16];      // Buffer para secuencias ANSI
  uint8_t ansi_buffer_pos;
  char cwd[VFS_PATH_MAX]; // Current working directory
  char path[512];         // PATH environment variable

  // Atributos de texto y prompt mejorado
  TextAttributes current_attrs; // Atributos de texto actuales
  TextAttributes saved_attrs;   // Atributos guardados
  PromptInfo prompt_info;       // InformaciÃ³n para el prompt
  uint32_t last_exit_code;      // CÃ³digo de salida del Ãºltimo comando
  char prompt_buffer[256];      // Buffer para el prompt renderizado
  uint32_t prompt_length;       // Longitud del prompt actual  // Â¡AGREGAR ESTO!
  uint8_t show_time_in_prompt;  // Mostrar hora en el prompt
  uint8_t show_user_in_prompt;  // Mostrar usuario en el prompt
  uint8_t show_path_in_prompt;  // Mostrar ruta en el prompt

  // EstadÃ­sticas para debug
  uint32_t total_lines_written;
  uint32_t page_faults_avoided;
} Terminal;

extern bool graphical_mode;

// Funciones para calcular dimensiones de terminal
uint32_t terminal_calculate_width(void);
uint32_t terminal_calculate_height(void);
void terminal_recalculate_dimensions(Terminal *term);
int terminal_resize(Terminal *term);

// Funciones del buffer circular
int circular_buffer_init(CircularBuffer *cb, uint32_t width,
                         uint32_t buffer_lines);
void circular_buffer_destroy(CircularBuffer *cb);
int circular_buffer_add_line(CircularBuffer *cb);
char *circular_buffer_get_line(CircularBuffer *cb, uint32_t line_offset);
uint32_t *circular_buffer_get_colors(CircularBuffer *cb, uint32_t line_offset);
uint32_t circular_buffer_get_line_attrs(CircularBuffer *cb,
                                        uint32_t line_offset);
void circular_buffer_set_line_attrs(CircularBuffer *cb, uint32_t line_offset,
                                    uint32_t attrs);
int circular_buffer_is_valid_line(CircularBuffer *cb, uint32_t line_offset);
void circular_buffer_clear(CircularBuffer *cb);
int circular_buffer_resize(CircularBuffer *cb, uint32_t new_width,
                           uint32_t new_buffer_lines);

// Funciones del terminal
uint32_t terminal_get_cursor_x(Terminal *term);
uint32_t terminal_get_cursor_y(Terminal *term);
void terminal_init(Terminal *term);
void terminal_destroy(Terminal *term);
void terminal_clear(Terminal *term);
void terminal_putchar(Terminal *term, char c);
void terminal_puts(Terminal *term, const char *str);
void terminal_handle_key(Terminal *term, int key);
void terminal_process_command(Terminal *term);
void terminal_draw(Terminal *term);
void terminal_scroll(Terminal *term);
void terminal_execute(Terminal *term, const char *cmd);
void terminal_update_cursor_blink(Terminal *term, uint32_t current_tick);
void terminal_scroll_up(Terminal *term);
void terminal_scroll_down(Terminal *term);
void terminal_printf(Terminal *term, const char *format, ...);
void terminal_scroll_to_bottom(Terminal *term);
void terminal_get_stats(Terminal *term, uint32_t *total_lines,
                        uint32_t *valid_lines, uint32_t *buffer_usage);
void terminal_draw_line(Terminal *term, uint32_t screen_y);

// Funciones nuevas para colores ANSI
uint32_t ansi_to_color(uint8_t ansi_code, uint8_t is_bright);
void terminal_apply_ansi_code(Terminal *term, int code);
void terminal_process_ansi_sequence(Terminal *term, const char *seq);
void terminal_putchar_with_attrs(Terminal *term, char c);

// Funciones para prompt mejorado
void terminal_update_prompt_info(Terminal *term);
void terminal_render_prompt(Terminal *term);
void terminal_show_enhanced_prompt(Terminal *term);
const char *terminal_get_prompt_color(Terminal *term, uint8_t is_error);

// Funciones de verificaciÃ³n y seguridad
int terminal_verify_memory_access(Terminal *term, uint32_t line_offset);
void terminal_safe_memset(char *ptr, char value, size_t size);
void terminal_safe_memcpy(char *dst, const char *src, size_t size);

void terminal_set_cursor(Terminal *term, uint32_t x, uint32_t y);
void terminal_set_color(Terminal *term, uint32_t fg, uint32_t bg);
void terminal_reset_colors(Terminal *term);
void terminal_show_cursor(Terminal *term, bool show);
uint32_t terminal_get_cursor_x(Terminal *term);
uint32_t terminal_get_cursor_y(Terminal *term);

#endif



================================================================================
FILE: stdbool.h
================================================================================

#ifndef _STDBOOL_H
#define _STDBOOL_H

#define bool _Bool
#define true 1
#define false 0

#endif




================================================================================
FILE: task.h
================================================================================

#ifndef TASK_H
#define TASK_H

#include "isr.h"
#include "memory.h"
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>

// Estados de las tareas
typedef enum {
  TASK_CREATED,  // Tarea creada pero no iniciada
  TASK_RUNNING,  // Tarea en ejecuciÃ³n
  TASK_READY,    // Tarea lista para ejecutar
  TASK_SLEEPING, // Tarea durmiendo
  TASK_WAITING,  // Tarea esperando por algo
  TASK_FINISHED, // Tarea terminada
  TASK_ZOMBIE    // Tarea terminada pero no recolectada
} task_state_t;

// Prioridades de tareas (0 = mÃ¡xima, 7 = mÃ­nima)
typedef enum {
  TASK_PRIORITY_HIGH = 0,
  TASK_PRIORITY_NORMAL = 3,
  TASK_PRIORITY_LOW = 7
} task_priority_t;

// TamaÃ±o del stack para cada tarea
#define TASK_STACK_SIZE (16 * 1024)
#define USER_STACK_SIZE (8 * 1024) // Stack mÃ¡s pequeÃ±o para usuario
#define MAX_TASKS 32
#define TASK_NAME_MAX 32

// Flags para tareas
#define TASK_FLAG_USER_MODE 0x00000001  // Ejecuta en modo usuario (Ring 3)
#define TASK_FLAG_USER_STACK 0x00000002 // Tiene stack de usuario asignado

// Contexto de CPU para cambio de tareas
typedef struct {
  // Registros de propÃ³sito general
  uint32_t eax, ebx, ecx, edx;
  uint32_t esi, edi, ebp, esp;
  uint32_t eip;

  // Registros de segmento
  uint32_t cs, ds, es, fs, gs, ss;

  // Flags
  uint32_t eflags;
} cpu_context_t;

// Estructura de control de tarea (TCB)
typedef struct task {
  uint32_t task_id;         // ID Ãºnico de la tarea
  char name[TASK_NAME_MAX]; // Nombre de la tarea
  task_state_t state;       // Estado actual
  task_priority_t priority; // Prioridad de la tarea

  // Contexto de CPU
  cpu_context_t context;

  // Stack de la tarea
  void *stack_base;  // Base del stack
  void *stack_top;   // Tope del stack
  size_t stack_size; // TamaÃ±o del stack

  // Stack de usuario (solo para tareas usuario)
  void *user_stack_base;
  void *user_stack_top;
  size_t user_stack_size;

  // **NUEVO: Flags para la tarea**
  uint32_t flags; // Flags de la tarea

  // InformaciÃ³n de usuario
  void *user_code_base;
  size_t user_code_size;
  void *user_entry_point; // <-- NUEVO: Punto de entrada de usuario
  address_space_t *address_space;

  // InformaciÃ³n de tiempo
  uint32_t time_slice;  // Quantum de tiempo asignado
  uint32_t sleep_until; // Tick hasta el que duerme
  uint32_t wake_time;   // Tiempo de despertar

  // Lista enlazada
  struct task *next; // Siguiente tarea en la lista
  struct task *prev; // Tarea anterior

  // FunciÃ³n de entrada y datos
  void (*entry_point)(void *); // FunciÃ³n principal de la tarea (kernel wrapper)
  void *arg;                   // Argumento para la funciÃ³n

  // EstadÃ­sticas
  uint32_t total_runtime; // Tiempo total de ejecuciÃ³n
  uint32_t switch_count;  // NÃºmero de cambios de contexto

  // Valor de retorno
  int exit_code; // CÃ³digo de salida

} task_t;

// Planificador de tareas
typedef struct {
  task_t *current_task; // Tarea actualmente en ejecuciÃ³n
  task_t *idle_task;    // Tarea idle del sistema
  task_t *task_list;    // Lista de todas las tareas

  uint32_t next_task_id;   // PrÃ³ximo ID de tarea a asignar
  uint32_t task_count;     // NÃºmero de tareas activas
  uint32_t total_switches; // Total de cambios de contexto

  bool scheduler_enabled; // Si el planificador estÃ¡ habilitado
  uint32_t quantum_ticks; // DuraciÃ³n del quantum en ticks
} task_scheduler_t;

// Funciones principales del planificador
void task_init(void);
task_t *task_create(const char *name, void (*entry_point)(void *), void *arg,
                    task_priority_t priority);
void task_destroy(task_t *task);
void task_yield(void);         // Ceder voluntariamente el CPU
void task_sleep(uint32_t ms);  // Dormir por tiempo especÃ­fico
void task_exit(int exit_code); // Terminar tarea actual

// Control del planificador
void scheduler_start(void);
void scheduler_stop(void);
void scheduler_tick(void);         // Llamar desde el timer interrupt
task_t *scheduler_next_task(void); // Obtener prÃ³xima tarea a ejecutar

// Funciones de informaciÃ³n
task_t *task_current(void); // Obtener tarea actual
task_t *task_find_by_id(uint32_t task_id);
task_t *task_find_by_name(const char *name);
void task_list_all(void); // Listar todas las tareas

// Funciones auxiliares
void task_setup_stack(task_t *task, void (*entry_point)(void *), void *arg);
bool task_is_ready(task_t *task);
void task_update_sleep_states(void);
void show_system_stats(void);
void stress_test_task(void *arg);
static bool validate_task_context(task_t *task);
void cleanup_task(void *arg);

// USER MODE
task_t *task_create_user(const char *name, void *user_code_addr, void *arg,
                         task_priority_t priority);
void task_setup_user_mode(task_t *task, void (*entry_point)(void *), void *arg,
                          void *user_stack);
// Macros Ãºtiles
#define CURRENT_TASK() task_current()
#define TASK_ID() (task_current() ? task_current()->task_id : 0)

// Selectores de segmento
#define KERNEL_CS 0x08
#define KERNEL_DS 0x10
#define USER_CS 0x1B // 0x18 | 3
#define USER_DS 0x23 // 0x20 | 3

// Declaraciones externas
extern task_scheduler_t scheduler;

#endif // TASK_H



================================================================================
FILE: memutils.h
================================================================================

#ifndef MEMUTILS_H
#define MEMUTILS_H

#include <stddef.h>
#include <stdint.h>


// Copia 'count' bytes de 'src' a 'dest'. Devuelve 'dest'.
void *memcpy(void *dest, const void *src, size_t count);

// Rellena 'count' bytes de 'dest' con el valor 'value'. Devuelve 'dest'.
void *memset(void *dest, int value, size_t count);

// Mueve 'count' bytes de 'src' a 'dest', permitiendo solapamiento. Devuelve 'dest'.
void *memmove(void *dest, const void *src, size_t count);

#endif




================================================================================
FILE: vfs.h
================================================================================

// vfs.h
#ifndef VFS_H
#define VFS_H

#include "memutils.h"
#include <stddef.h>
#include <stdint.h>

/* Ajustes */
#define VFS_MAX_FDS 64
#define VFS_MAX_FS_TYPES 8
#define VFS_MAX_MOUNTS 8
#define VFS_PATH_MAX 256
#define VFS_NAME_MAX 32
#define SECTOR_SIZE 512

/* Errores */
#define VFS_OK 0
#define VFS_ERR -1

/* Vnode types - EXTENDIDOS */
#define VFS_NODE_DIR 1
#define VFS_NODE_FILE 2
#define VFS_NODE_SYMLINK 3 // Nuevo: enlace simbÃ³lico
#define VFS_NODE_CHRDEV 4  // Nuevo: dispositivo carÃ¡cter
#define VFS_NODE_BLKDEV 5  // Nuevo: dispositivo bloque

/* File flags - EXTENDIDOS */
#define VFS_O_RDONLY 0x1
#define VFS_O_WRONLY 0x2
#define VFS_O_RDWR 0x4
#define VFS_O_CREAT 0x8
#define VFS_O_TRUNC 0x10
#define VFS_O_EXCL 0x20     // Nuevo: fallar si existe
#define VFS_O_NOFOLLOW 0x40 // Nuevo: no seguir symlinks

/* Flags de montaje */
#define VFS_MOUNT_RDONLY 0x1
#define VFS_MOUNT_NOEXEC 0x2
#define VFS_MOUNT_NOSUID 0x4
#define VFS_MOUNT_BIND 0x8       // Bind mount
#define VFS_MOUNT_RECURSIVE 0x10 // Bind mount recursivo

/* Path resolution flags */
#define VFS_RESOLVE_NOFOLLOW 0x1 // No seguir Ãºltimo symlink
#define VFS_RESOLVE_BENEATH 0x2  // No salir del root del filesystem

/* Forward decls */
struct vfs_superblock;
struct vfs_file;
struct vfs_node;
struct vfs_mount_info; // NUEVO: forward declaration
extern int mount_count;

/* DefiniciÃ³n completa de vfs_node_t ANTES de vnode_ops_t */
typedef struct vfs_node {
  char name[VFS_NAME_MAX];
  uint8_t type;     /* VFS_NODE_DIR / VFS_NODE_FILE */
  void *fs_private; /* FS-specific pointer */
  struct vnode_ops *ops;
  struct vfs_superblock *sb;
  uint32_t refcount;
} vfs_node_t;

typedef enum { VFS_DEV_BLOCK = 1, VFS_DEV_CHAR = 2 } vfs_dev_type_t;

/* Nota: esto protege en kernels uniprocesador con preemptive IRQs. */
static inline unsigned int vfs_lock_disable_irq(void) {
  unsigned int flags;
  __asm__ __volatile__("pushf\n\tcli\n\tpop %0" : "=r"(flags));
  return flags;
}
static inline void vfs_unlock_restore_irq(unsigned int flags) {
  __asm__ __volatile__("push %0\n\tpopf" : : "r"(flags));
}

/* Dirent structure - EXTENDIDO */
typedef struct vfs_dirent {
  char name[VFS_NAME_MAX];
  uint8_t type;  /* VFS_NODE_DIR, VFS_NODE_FILE, VFS_NODE_SYMLINK, etc. */
  uint32_t size; // Nuevo: tamaÃ±o para symlinks
  char link_target[VFS_PATH_MAX]; // Nuevo: destino para symlinks
} vfs_dirent_t;

/* vnode operations - EXTENDIDOS */
typedef struct vnode_ops {
  int (*lookup)(vfs_node_t *parent, const char *name, vfs_node_t **out);
  int (*create)(vfs_node_t *parent, const char *name, vfs_node_t **out);
  int (*mkdir)(vfs_node_t *parent, const char *name, vfs_node_t **out);
  int (*read)(vfs_node_t *node, uint8_t *buf, uint32_t size, uint32_t offset);
  int (*write)(vfs_node_t *node, const uint8_t *buf, uint32_t size,
               uint32_t offset);
  int (*readdir)(vfs_node_t *node, vfs_dirent_t *buf, uint32_t *count,
                 uint32_t offset);
  void (*release)(vfs_node_t *node);
  int (*unlink)(vfs_node_t *parent, const char *name);

  // Nuevas operaciones
  int (*symlink)(vfs_node_t *parent, const char *name, const char *target);
  int (*readlink)(vfs_node_t *node, char *buf, uint32_t size);
  int (*truncate)(vfs_node_t *node, uint32_t size);
  int (*getattr)(vfs_node_t *node, vfs_dirent_t *attr);
} vnode_ops_t;

/* Resto del archivo sin cambios */
typedef struct file_ops {
  int (*read)(struct vfs_file *f, uint8_t *buf, uint32_t size);
  int (*write)(struct vfs_file *f, const uint8_t *buf, uint32_t size);
  int (*close)(struct vfs_file *f);
} file_ops_t;

/* Superblock - EXTENDIDO con flags de montaje */
typedef struct vfs_superblock {
  char fs_name[16];
  void *private; /* FS private data */
  vfs_node_t *root;
  void *backing_device;               /* e.g. disk_t* or NULL */
  uint32_t flags;                     /* Flags de montaje */
  struct vfs_superblock *bind_source; /* CORRECCIÃ“N: usa struct aquÃ­ */
  char bind_path[VFS_PATH_MAX];       /* Path dentro del source */
  uint32_t refcount;                  /* Contador de referencias */
} vfs_superblock_t;

/* open file descriptor (internal) */
typedef struct vfs_file {
  vfs_node_t *node;
  uint32_t flags;
  uint32_t offset;
  file_ops_t *ops;
  uint32_t refcount;
} vfs_file_t;

/* FS type registration */
typedef int (*fs_mount_fn)(void *device, vfs_superblock_t **out_sb);
typedef int (*fs_unmount_fn)(
    vfs_superblock_t *sb); // Nueva: callback para unmount

typedef struct vfs_fs_type {
  char name[16];
  fs_mount_fn mount;
  fs_unmount_fn unmount; // Nueva
} vfs_fs_type_t;

/* Mount info para tabla de montajes */
typedef struct vfs_mount_info {
  vfs_superblock_t *sb;
  char mountpoint[VFS_PATH_MAX];
  char source[VFS_PATH_MAX]; // Dispositivo fuente o "none"
  char fs_type[16];
  uint32_t flags;
  struct vfs_mount_info *next; // Para lista enlazada
} vfs_mount_info_t;

extern vfs_mount_info_t *mount_list;

/* Public API (POSIX-like fd interface) */
void vfs_init(void);
int vfs_register_fs(const vfs_fs_type_t *fs);
int vfs_mount(const char *mountpoint, const char *fsname, void *device);
int vfs_open(const char *path, uint32_t flags); /* returns fd or -1 */
int vfs_read(int fd, void *buf, uint32_t size);
int vfs_write(int fd, const void *buf, uint32_t size);
int vfs_close(int fd);
int vfs_unlink(const char *path); // Nueva funciÃ³n pÃºblica
int vfs_unlink_recursive(const char *path, int recursive);
int vfs_mknod(const char *path, vfs_dev_type_t dev_type, uint32_t major,
              uint32_t minor);
int vfs_symlink(const char *target, const char *linkpath);
int vfs_readlink(const char *path, char *buf, uint32_t size);
int vfs_bind_mount(const char *source, const char *target, int recursive);
int vfs_umount(const char *mountpoint, int flags);
int vfs_stat(const char *path, vfs_dirent_t *statbuf);
int vfs_lstat(const char *path, vfs_dirent_t *statbuf); // No sigue symlinks
vfs_node_t *vfs_resolve_path(const char *path, uint32_t flags,
                             vfs_superblock_t **out_sb,
                             const char **out_relpath);

/* Path resolution functions */
vfs_node_t *resolve_path_to_vnode(vfs_superblock_t *sb, const char *relpath);
vfs_superblock_t *find_mount_for_path(const char *path,
                                      const char **out_relpath);

/* Path utility function */
int vfs_split_path(const char *path, char *parent_path, char *name);
int vfs_normalize_path(const char *input, char *output, size_t output_size);

/* List all active mounts */
int vfs_list_mounts(void (*callback)(const char *mountpoint,
                                     const char *fs_name, void *arg),
                    void *arg);
int close_fds_for_mount(vfs_superblock_t *sb);

// Fix: Agregar declaraciones pÃºblicas para mkdir y unmount
int vfs_mkdir(const char *path, vfs_node_t **out);
int vfs_unmount(const char *mountpoint);
void debug_hex_dump(const char *label, const char *str, size_t len);

#endif /* VFS_H */



================================================================================
FILE: kernel.h
================================================================================

#ifndef KERNEL_H
#define KERNEL_H

#include "boot_log.h"
#include "disk.h"
#include "installer.h"
#include "memory.h"
#include "memutils.h"
#include "multiboot2.h" // AsegÃºrate de tener este archivo con las definiciones de Multiboot2
#include "string.h"
#include "terminal.h"
#include <stddef.h>
#include <stdint.h>

// Heap estÃ¡tico de reserva
// Heap estÃ¡tico de reserva
#define STATIC_HEAP_SIZE 0x1000000 // 16 MB
extern uint8_t kernel_heap[STATIC_HEAP_SIZE];

extern uint32_t *g_framebuffer;
extern uint32_t g_pitch_pixels;
extern uint32_t g_screen_width;
extern uint32_t g_screen_height;
extern disk_t main_disk;
extern install_options_t options;
extern bool graphical_mode;

// InformaciÃ³n que pasa el bootloader
typedef struct {
  uint32_t magic;
  struct multiboot_tag *multiboot_info_ptr;
  struct multiboot_tag_framebuffer *framebuffer;
  struct multiboot_tag_mmap *mmap;
} BootInfo;

extern BootInfo boot_info;
extern Terminal main_terminal;

// Punto de entrada del kernel (llamado desde el bootloader)
void cmain(uint32_t magic, struct multiboot_tag *mb_info);
void shutdown(void);
void test_simple_messages(void);
void keyboard_terminal_handler(int key);
void unmount_callback(const char *mountpoint, const char *fs_name, void *arg);

#endif




================================================================================
FILE: boot_log.h
================================================================================

#ifndef BOOT_LOG_H
#define BOOT_LOG_H

#include <stdint.h>
#include <stdbool.h>

// Colores para mensajes de boot
#define BOOT_COLOR_INFO    0x00FFFF  // Cyan
#define BOOT_COLOR_OK      0x00FF00  // Verde
#define BOOT_COLOR_ERROR   0xFF0000  // Rojo
#define BOOT_COLOR_WARN    0xFFFF00  // Amarillo
#define BOOT_COLOR_TEXT    0xFFFFFF  // Blanco

// Estado del sistema de boot
typedef struct {
    bool boot_phase;           // true durante el boot, false despuÃ©s
    uint32_t current_line;     // LÃ­nea actual en pantalla
    uint32_t max_lines;        // MÃ¡ximo de lÃ­neas disponibles
    uint32_t step_count;       // Contador de pasos de boot
} boot_state_t;

extern boot_state_t boot_state;

// Funciones pÃºblicas
void boot_log_init(void);
void boot_log_start(const char* message);
void boot_log_ok(void);
void boot_log_error(void);
void boot_log_info(const char* format, ...);
void boot_log_warn(const char* format, ...);
void boot_log_finish(void);
bool boot_is_active(void);

// Funciones auxiliares
void boot_log_draw_progress_bar(uint32_t current, uint32_t total);
void boot_log_clear_screen(void);

#endif // BOOT_LOG_H


================================================================================
FILE: partition.h
================================================================================

#ifndef PARTITION_H
#define PARTITION_H

#include "disk.h"
#include <stdbool.h>
#include <stdint.h>


// Partition types
#define PART_TYPE_EMPTY 0x00
#define PART_TYPE_FAT12 0x01
#define PART_TYPE_FAT16_SMALL 0x04
#define PART_TYPE_EXTENDED 0x05
#define PART_TYPE_FAT16 0x06
#define PART_TYPE_NTFS 0x07
#define PART_TYPE_FAT32 0x0B
#define PART_TYPE_FAT32_LBA 0x0C
#define PART_TYPE_FAT16_LBA 0x0E
#define PART_TYPE_EXTENDED_LBA 0x0F
#define PART_TYPE_LINUX 0x83
#define PART_TYPE_GPT 0xEE

// Partition flags
#define PART_FLAG_BOOTABLE 0x80

// MBR Partition Entry (16 bytes)
typedef struct __attribute__((packed)) {
  uint8_t status;        // 0x80 = bootable, 0x00 = non-bootable
  uint8_t first_chs[3];  // CHS address of first sector
  uint8_t type;          // Partition type
  uint8_t last_chs[3];   // CHS address of last sector
  uint32_t lba_start;    // LBA of first sector
  uint32_t sector_count; // Number of sectors
} mbr_partition_entry_t;

// Master Boot Record (512 bytes)
typedef struct __attribute__((packed)) {
  uint8_t boot_code[446];              // Bootstrap code
  mbr_partition_entry_t partitions[4]; // Partition table
  uint16_t signature;                  // 0xAA55
} mbr_t;

// Parsed partition information
typedef struct partition_info_t {
  uint8_t index;         // Partition index (0-3 for primary)
  uint8_t type;          // Partition type
  bool bootable;         // Bootable flag
  uint64_t lba_start;    // Starting LBA
  uint64_t sector_count; // Size in sectors
  uint64_t size_mb;      // Size in MB
  bool is_extended;      // Extended partition
} partition_info_t;

// Partition table context
typedef struct {
  disk_t *disk;
  mbr_t mbr;
  partition_info_t partitions[4];
  uint32_t partition_count;
} partition_table_t;

// Error codes
typedef enum {
  PART_OK = 0,
  PART_ERR_INVALID_DISK,
  PART_ERR_READ_FAILED,
  PART_ERR_INVALID_MBR,
  PART_ERR_NO_PARTITIONS,
  PART_ERR_WRITE_FAILED,
  PART_ERR_INVALID_INDEX
} part_err_t;

// Functions
part_err_t partition_read_table(disk_t *disk, partition_table_t *pt);
part_err_t partition_write_table(partition_table_t *pt);
const char *partition_type_name(uint8_t type);
bool partition_is_fat(uint8_t type);
void partition_print_info(partition_table_t *pt);
partition_info_t *partition_find_bootable(partition_table_t *pt);
partition_info_t *partition_find_by_type(partition_table_t *pt, uint8_t type);
part_err_t partition_set_bootable(partition_table_t *pt, uint8_t index);
// Nueva funciÃ³n para crear una entrada de particiÃ³n
void partition_create_entry(mbr_partition_entry_t *entry, uint8_t type,
                            uint64_t start_lba, uint64_t sector_count,
                            bool bootable);

// FunciÃ³n para verificar espacio libre
uint64_t partition_find_free_space(partition_table_t *pt,
                                   uint64_t size_sectors);

// FunciÃ³n para calcular CHS desde LBA (simplificada)
void partition_lba_to_chs(uint64_t lba, uint8_t *chs);

// FunciÃ³n para limpiar tabla de particiones
void partition_clear_table(partition_table_t *pt);

#endif // PARTITION_H



================================================================================
FILE: idt.h
================================================================================

#ifndef IDT_H
#define IDT_H

#include <stddef.h>
#include <stdint.h>


#define IDT_ENTRIES         256
#define KERNEL_CODE_SELECTOR 0x08

#define IDT_FLAG_PRESENT     0x80
#define IDT_FLAG_RING0       0x00
#define IDT_FLAG_RING3       0x60
#define IDT_FLAG_INTERRUPT32 0x0E

#define IDT_ENTRY_FLAGS      (IDT_FLAG_PRESENT | IDT_FLAG_RING0 | IDT_FLAG_INTERRUPT32)

#define PIC1_COMMAND 0x20
#define PIC1_DATA    0x21
#define PIC2_COMMAND 0xA0
#define PIC2_DATA    0xA1
#define PIC_EOI      0x20


typedef struct {
    uint16_t offset_low;
    uint16_t selector;
    uint8_t  zero;
    uint8_t  type_attr;
    uint16_t offset_high;
} __attribute__((packed)) idt_entry_t;

typedef struct {
    uint16_t limit;
    uint32_t base;
} __attribute__((packed)) idt_ptr_t;

void idt_init(void);
void idt_set_gate(uint8_t num, uintptr_t base, uint16_t selector, uint8_t flags);
void pic_remap(int offset1, int offset2);

#endif



================================================================================
FILE: task_test.h
================================================================================

#ifndef TASK_TEST_H
#define TASK_TEST_H

// ========================================================================
// TEST SUITE
// ========================================================================

#ifdef __cplusplus
extern "C" {
#endif

void run_task_utils_test_suite(void);
void test_task_utils_command(void);

#ifdef __cplusplus
}
#endif

#endif // TASK_TEST_H



================================================================================
FILE: pmm.h
================================================================================

// pmm.h - NUEVO ARCHIVO
#ifndef PMM_H
#define PMM_H

#include "multiboot2.h"
#include "terminal.h"
#include <stddef.h>
#include <stdint.h>

// Constantes
#define MAX_MEMORY_REGIONS 32

// Estructuras
typedef struct {
  uint64_t base;
  uint64_t length;
  uint8_t used;
} mem_region_t;

typedef struct {
  uint32_t *bitmap;
  uint32_t total_pages;
  uint32_t free_pages;
  uint32_t bitmap_size;
} pmm_bitmap_t;

// Variables globales
extern mem_region_t mem_regions[MAX_MEMORY_REGIONS];
extern uint32_t mem_region_count;
extern pmm_bitmap_t pmm_bitmap;

// Prototipos de funciones
void pmm_init(struct multiboot_tag_mmap *mmap_tag);
void pmm_exclude_kernel_heap(void *heap_start, size_t heap_size);
void *pmm_alloc_page(void);
void *pmm_alloc_pages(uint32_t count);
void pmm_free_page(void *page);
void pmm_free_pages(void *base, uint32_t count);
uint32_t pmm_get_free_pages(void);
uint32_t pmm_get_total_pages(void);
void pmm_debug_info(Terminal *term);

#endif



================================================================================
FILE: string.h
================================================================================

#ifndef STRING_H
#define STRING_H

#include <stddef.h>
#include <stdint.h>
#include <stdarg.h>

// Avoid redefining standard functions in kernel code to prevent conflicts
#ifndef KERNEL_BUILD
#define itoa kitoa
#define snprintf ksnprintf
#define strlcpy kstrlcpy
#endif

void __udivmoddi4(uint64_t dividend, uint64_t divisor, uint64_t *quotient, uint64_t *remainder);
void to_hex(uint64_t val, char *buf);
void to_decimal(uint32_t val, char *buf);
int sprintf(char *buf, const char *fmt, ...);
static void reverse(char *s, int len);
size_t strlen(const char *str);
unsigned long long __udivdi3(unsigned long long n, unsigned long long d);
char* kitoa(int value, char* str, int base);
int int_itoa(int value, char* str, int base);
int snprintf(char *str, size_t size, const char *format, ...);
size_t kstrlcpy(char *dst, const char *src, size_t size);
char* uitoa(uint32_t value, char* str, int base);
void ulltoa(unsigned long long value, char *buf, int base);
char* strcat(char *dest, const char *src);
int strncmp(const char *s1, const char *s2, unsigned int n);
int strcmp(const char *s1, const char *s2);
char* trim_whitespace(char *str);
int isspace(int c);
char* strcpy(char *dest, const char *src);
char* strncpy(char* dest, const char* src, size_t n);
unsigned long strtoul(const char* str, char** endptr, int base);
int atoi(const char* str);
long strtol(const char *nptr, char **endptr, int base);
uint64_t strtoull(const char* str, char** endptr, int base);
int memcmp(const void* ptr1, const void* ptr2, size_t num);
char* strncat(char* dest, const char* src, size_t n);
char *strtok(char *str, const char *delim);
char *strchr(const char *str, int c);
char *strrchr(const char *str, int c);
char *strtok_r(char *str, const char *delim, char **saveptr);
size_t strcspn(const char *str1, const char *str2) ;
size_t strnlen(const char *s, size_t maxlen);
void u64_to_str(uint64_t value, char* buffer);
char* strstr(const char* haystack, const char* needle);
int vsnprintf(char *str, size_t size, const char *format, va_list args);
int toupper(int c);
void strupper(char *s);
int sscanf(const char *str, const char *fmt, ...);

#endif



================================================================================
FILE: disk.h
================================================================================

#ifndef DISK_H
#define DISK_H

#include <stdbool.h>
#include <stdint.h>

#define DISK_DRIVE_IDE_MASTER 0x00
#define DISK_DRIVE_IDE_SLAVE 0x01
#define DISK_DRIVE_IDE_SEC_MASTER 0x02
#define DISK_DRIVE_IDE_SEC_SLAVE 0x03
#define DISK_DRIVE_SATA_FIRST 0x80  // Primer disco SATA
#define DISK_DRIVE_ATAPI_FIRST 0xE0 // Primer dispositivo ATAPI

#define SECTOR_SIZE 512

typedef struct partition_info_t partition_info_t;
typedef struct disk_t disk_t;

typedef enum {
  DEVICE_TYPE_NONE = 0,
  DEVICE_TYPE_PATA_DISK,
  DEVICE_TYPE_PATAPI_CDROM,
  DEVICE_TYPE_SATA_DISK,
  DEVICE_TYPE_SATAPI_CDROM,
  DEVICE_TYPE_USB_DISK,
  DEVICE_TYPE_UNKNOWN
} device_type_t;

struct disk_t {
  uint8_t drive_number;
  uint8_t initialized; // 0 = not initialized, 1 = initialized
  uint8_t present;
  uint8_t supports_lba48;        // 0 = LBA28 only, 1 = supports LBA48
  uint64_t sector_count;         // Use uint64_t for LBA48 support
  device_type_t type;            // IDE or SATA
  uint64_t partition_lba_offset; // Offset LBA de la particiÃ³n
  bool is_partition;             // true si es wrapper de particiÃ³n
  disk_t *physical_disk; // Pointer to physical disk if this is a partition;
                         // NULL otherwise
};

// Disk operation states
typedef enum { DISK_OP_NONE, DISK_OP_READ, DISK_OP_WRITE } disk_op_t;

// Error codes
typedef enum {
  DISK_ERR_NONE = 0,
  DISK_ERR_INVALID_PARAM,
  DISK_ERR_NOT_INITIALIZED,
  DISK_ERR_TIMEOUT,
  DISK_ERR_DEVICE_NOT_PRESENT,
  DISK_ERR_ATA,
  DISK_ERR_ATAPI,
  DISK_ERR_LBA_OUT_OF_RANGE
} disk_err_t;

typedef struct {
  bool present;
  device_type_t type;
  uint8_t bus;
  uint8_t drive;
  char description[64];
} detected_device_t;

// Firmware signature detection
typedef enum {
  FIRMWARE_ATA = 0,
  FIRMWARE_ATAPI = 1,
  FIRMWARE_UNKNOWN = 2
} firmware_signature_t;

inline uint64_t rdtsc(void) {
  uint32_t lo, hi;
  asm volatile("rdtsc" : "=a"(lo), "=d"(hi));
  return ((uint64_t)hi << 32) | lo;
}

// Basic functions
disk_err_t disk_init(disk_t *disk, uint8_t drive_number);

disk_err_t disk_read(disk_t *disk, uint64_t lba, uint32_t count, void *buffer);
disk_err_t disk_write(disk_t *disk, uint64_t lba, uint32_t count,
                      const void *buffer);
uint64_t disk_get_sector_count(disk_t *disk);
int disk_is_initialized(disk_t *disk);
uint32_t disk_get_io_ticks(void);
uint64_t disk_get_io_cycles(void);
disk_err_t disk_flush(disk_t *disk);
disk_err_t disk_init_from_partition(disk_t *partition_disk,
                                    disk_t *physical_disk,
                                    partition_info_t *partition);

// Dispatch functions for unified disk interface
disk_err_t disk_read_dispatch(disk_t *disk, uint64_t lba, uint32_t count,
                              void *buffer);
disk_err_t disk_write_dispatch(disk_t *disk, uint64_t lba, uint32_t count,
                               const void *buffer);
disk_err_t disk_flush_dispatch(disk_t *disk);
void diagnose_disk_format(disk_t *disk);

disk_err_t disk_init_atapi(disk_t *disk, uint32_t atapi_device_id);
bool disk_is_atapi(disk_t *disk);
bool disk_atapi_media_present(disk_t *disk);
disk_err_t disk_atapi_eject(disk_t *disk);
disk_err_t disk_atapi_load(disk_t *disk);

void disk_list_detected_devices(void);
void disk_scan_all_buses(void);
void cmd_lsblk(void);

// Convenience macros for cleaner code
#define DISK_READ(disk, lba, count, buffer)                                    \
  disk_read_dispatch(disk, lba, count, buffer)
#define DISK_WRITE(disk, lba, count, buffer)                                   \
  disk_write_dispatch(disk, lba, count, buffer)
#define DISK_FLUSH(disk) disk_flush_dispatch(disk)

// Global state variables
extern volatile disk_op_t disk_current_op;
extern volatile void *disk_current_buffer;
extern volatile uint32_t disk_remaining_sectors;
extern volatile disk_err_t disk_error;
extern volatile uint32_t total_io_ticks;
extern volatile uint64_t total_io_cycles;

#endif




================================================================================
FILE: types.h
================================================================================

// types.h
#ifndef TYPES_H
#define TYPES_H

#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

// Tipos bÃ¡sicos del sistema
typedef int32_t pid_t;      // ID de proceso
typedef int32_t fd_t;       // Descriptor de archivo
typedef uint32_t mode_t;    // Permisos de archivo
typedef int32_t ssize_t;    // Signed size_t
typedef uint32_t uid_t;     // ID de usuario
typedef uint32_t gid_t;     // ID de grupo
typedef int32_t off_t;      // Offset de archivo
typedef uint32_t dev_t;     // NÃºmero de dispositivo
typedef uint32_t ino_t;     // NÃºmero de inodo
typedef uint32_t nlink_t;   // NÃºmero de enlaces
typedef uint32_t blksize_t; // TamaÃ±o de bloque
typedef uint32_t blkcnt_t;  // Contador de bloques
typedef uint32_t time_t;    // Tiempo

// Para compatibilidad
#ifndef __SIZE_TYPE__
#define __SIZE_TYPE__ unsigned int
#endif

#ifndef NULL
#define NULL ((void*)0)
#endif

#endif // TYPES_H



================================================================================
FILE: module_loader.h
================================================================================

#ifndef MODULE_LOADER_H
#define MODULE_LOADER_H

#include <stdint.h>
#include <stdbool.h>
#include "multiboot2.h"

// InformaciÃ³n de un mÃ³dulo cargado
typedef struct {
    uint32_t start;     // DirecciÃ³n fÃ­sica de inicio
    uint32_t end;       // DirecciÃ³n fÃ­sica de fin
    uint32_t size;      // TamaÃ±o en bytes
    char* cmdline;      // LÃ­nea de comandos del mÃ³dulo (allocated)
    void* data;         // Puntero a los datos del mÃ³dulo
} module_info_t;

// Lista de mÃ³dulos encontrados
extern module_info_t* loaded_modules;
extern uint32_t module_count;

// Funciones principales
bool module_loader_init(struct multiboot_tag* mb_info);
module_info_t* module_find_by_name(const char* name);
module_info_t* module_get_by_index(uint32_t index);
void module_list_all(void);
void module_loader_cleanup(void);

// Funciones de debugging y diagnÃ³stico
void module_debug_multiboot_info(struct multiboot_tag* mb_info);
void module_check_grub_config(void);
bool module_verify_multiboot_magic(uint32_t magic);

// Macros Ãºtiles
#define MODULE_EXISTS(name) (module_find_by_name(name) != NULL)
#define MODULE_COUNT() (module_count)
#define MODULE_GET(index) module_get_by_index(index)

#endif



================================================================================
FILE: tmpfs.h
================================================================================

/* tmpfs.h */
#ifndef TMPFS_H
#define TMPFS_H

#include "vfs.h"

/* DeclaraciÃ³n de la instancia global del FS */
extern vfs_fs_type_t tmpfs_type;

/* Prototipo de la funciÃ³n mount */
int tmpfs_mount(void *device, vfs_superblock_t **out_sb);
void test_tmpfs(void);

#endif



================================================================================
FILE: driver_system.h
================================================================================

// driver_system.h - Generic driver system
#ifndef DRIVER_SYSTEM_H
#define DRIVER_SYSTEM_H

#include <stdint.h>
#include "vfs.h"

#define DRIVER_MAX_TYPES 16
#define DRIVER_MAX_INSTANCES 32
#define DRIVER_NAME_MAX 32
#define DRIVER_VERSION_MAX 16

// Driver types
typedef enum {
    DRIVER_TYPE_UNKNOWN = 0,
    DRIVER_TYPE_KEYBOARD,
    DRIVER_TYPE_MOUSE,
    DRIVER_TYPE_AUDIO,
    DRIVER_TYPE_NETWORK,
    DRIVER_TYPE_STORAGE,
    DRIVER_TYPE_VIDEO,
    DRIVER_TYPE_USB,
    DRIVER_TYPE_MAX
} driver_type_t;

// Driver state
typedef enum {
    DRIVER_STATE_UNLOADED = 0,
    DRIVER_STATE_LOADING,
    DRIVER_STATE_LOADED,
    DRIVER_STATE_ACTIVE,
    DRIVER_STATE_ERROR
} driver_state_t;

// Forward declarations
struct driver_instance;
struct driver_type_info;

// Generic driver operations
typedef struct driver_ops {
    int (*init)(struct driver_instance *drv, void *config);
    int (*start)(struct driver_instance *drv);
    int (*stop)(struct driver_instance *drv);
    int (*cleanup)(struct driver_instance *drv);
    int (*ioctl)(struct driver_instance *drv, uint32_t cmd, void *arg);
    int (*load_data)(struct driver_instance *drv, const void *data, size_t size);
} driver_ops_t;

// Driver instance
typedef struct driver_instance {
    uint32_t id;
    char name[DRIVER_NAME_MAX];
    char version[DRIVER_VERSION_MAX];
    driver_type_t type;
    driver_state_t state;
    void *private_data;
    const driver_ops_t *ops;
    struct driver_type_info *type_info;
    struct driver_instance *next;
} driver_instance_t;

// Driver type information
typedef struct driver_type_info {
    driver_type_t type;
    char type_name[DRIVER_NAME_MAX];
    char version[DRIVER_VERSION_MAX];
    size_t private_data_size;
    const driver_ops_t *default_ops;
    int (*validate_data)(const void *data, size_t size);
    void (*print_info)(const driver_instance_t *drv);
} driver_type_info_t;

// Public API
int driver_system_init(void);
void driver_system_cleanup(void);

// Driver type registration
int driver_register_type(const driver_type_info_t *type_info);
driver_type_info_t *driver_get_type_info(driver_type_t type);

// Driver instance management
driver_instance_t *driver_create(driver_type_t type, const char *name);
int driver_destroy(driver_instance_t *drv);
driver_instance_t *driver_find_by_name(const char *name);
driver_instance_t *driver_find_by_type(driver_type_t type);

// Driver operations
int driver_init(driver_instance_t *drv, void *config);
int driver_start(driver_instance_t *drv);
int driver_stop(driver_instance_t *drv);
int driver_ioctl(driver_instance_t *drv, uint32_t cmd, void *arg);

// File loading utilities
void *driver_load_binary_file(const char *filename, size_t *out_size);
int driver_unload_binary_file(void *data, size_t size);
int driver_load_from_file(driver_instance_t *drv, const char *filename);

// List and debug functions
void driver_list_all(void);
void driver_list_by_type(driver_type_t type);

#endif // DRIVER_SYSTEM_H



================================================================================
FILE: boot_img.h
================================================================================

unsigned char boot_img[] = {
  0xeb, 0x63, 0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xff, 0xfa, 0xeb, 0x05, 0xf6, 0xc2, 0x80, 0x74,
  0x05, 0xf6, 0xc2, 0x70, 0x74, 0x02, 0xb2, 0x80, 0xea, 0x79, 0x7c, 0x00,
  0x00, 0x31, 0xc0, 0x8e, 0xd8, 0x8e, 0xd0, 0xbc, 0x00, 0x20, 0xfb, 0xa0,
  0x64, 0x7c, 0x3c, 0xff, 0x74, 0x02, 0x88, 0xc2, 0x52, 0xbb, 0x17, 0x04,
  0xf6, 0x07, 0x03, 0x74, 0x06, 0xbe, 0x88, 0x7d, 0xe8, 0x17, 0x01, 0xbe,
  0x05, 0x7c, 0xb4, 0x41, 0xbb, 0xaa, 0x55, 0xcd, 0x13, 0x5a, 0x52, 0x72,
  0x3d, 0x81, 0xfb, 0x55, 0xaa, 0x75, 0x37, 0x83, 0xe1, 0x01, 0x74, 0x32,
  0x31, 0xc0, 0x89, 0x44, 0x04, 0x40, 0x88, 0x44, 0xff, 0x89, 0x44, 0x02,
  0xc7, 0x04, 0x10, 0x00, 0x66, 0x8b, 0x1e, 0x5c, 0x7c, 0x66, 0x89, 0x5c,
  0x08, 0x66, 0x8b, 0x1e, 0x60, 0x7c, 0x66, 0x89, 0x5c, 0x0c, 0xc7, 0x44,
  0x06, 0x00, 0x70, 0xb4, 0x42, 0xcd, 0x13, 0x72, 0x05, 0xbb, 0x00, 0x70,
  0xeb, 0x76, 0xb4, 0x08, 0xcd, 0x13, 0x73, 0x0d, 0x5a, 0x84, 0xd2, 0x0f,
  0x83, 0xd0, 0x00, 0xbe, 0x93, 0x7d, 0xe9, 0x82, 0x00, 0x66, 0x0f, 0xb6,
  0xc6, 0x88, 0x64, 0xff, 0x40, 0x66, 0x89, 0x44, 0x04, 0x0f, 0xb6, 0xd1,
  0xc1, 0xe2, 0x02, 0x88, 0xe8, 0x88, 0xf4, 0x40, 0x89, 0x44, 0x08, 0x0f,
  0xb6, 0xc2, 0xc0, 0xe8, 0x02, 0x66, 0x89, 0x04, 0x66, 0xa1, 0x60, 0x7c,
  0x66, 0x09, 0xc0, 0x75, 0x4e, 0x66, 0xa1, 0x5c, 0x7c, 0x66, 0x31, 0xd2,
  0x66, 0xf7, 0x34, 0x88, 0xd1, 0x31, 0xd2, 0x66, 0xf7, 0x74, 0x04, 0x3b,
  0x44, 0x08, 0x7d, 0x37, 0xfe, 0xc1, 0x88, 0xc5, 0x30, 0xc0, 0xc1, 0xe8,
  0x02, 0x08, 0xc1, 0x88, 0xd0, 0x5a, 0x88, 0xc6, 0xbb, 0x00, 0x70, 0x8e,
  0xc3, 0x31, 0xdb, 0xb8, 0x01, 0x02, 0xcd, 0x13, 0x72, 0x1e, 0x8c, 0xc3,
  0x60, 0x1e, 0xb9, 0x00, 0x01, 0x8e, 0xdb, 0x31, 0xf6, 0xbf, 0x00, 0x80,
  0x8e, 0xc6, 0xfc, 0xf3, 0xa5, 0x1f, 0x61, 0xff, 0x26, 0x5a, 0x7c, 0xbe,
  0x8e, 0x7d, 0xeb, 0x03, 0xbe, 0x9d, 0x7d, 0xe8, 0x34, 0x00, 0xbe, 0xa2,
  0x7d, 0xe8, 0x2e, 0x00, 0xcd, 0x18, 0xeb, 0xfe, 0x47, 0x52, 0x55, 0x42,
  0x20, 0x00, 0x47, 0x65, 0x6f, 0x6d, 0x00, 0x48, 0x61, 0x72, 0x64, 0x20,
  0x44, 0x69, 0x73, 0x6b, 0x00, 0x52, 0x65, 0x61, 0x64, 0x00, 0x20, 0x45,
  0x72, 0x72, 0x6f, 0x72, 0x0d, 0x0a, 0x00, 0xbb, 0x01, 0x00, 0xb4, 0x0e,
  0xcd, 0x10, 0xac, 0x3c, 0x00, 0x75, 0xf4, 0xc3, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00
};
unsigned int boot_img_len = 446;




================================================================================
FILE: exec.h
================================================================================

#ifndef EXEC_H
#define EXEC_H

#include "task.h"
#include "vfs.h"
#include <stdint.h>

// ConfiguraciÃ³n de memoria para ejecutables
#define EXEC_CODE_BASE 0x00400000       // 4MB - donde se carga el cÃ³digo
#define EXEC_STACK_SIZE (16 * 1024)     // 16KB de stack por defecto
#define EXEC_MAX_SIZE (2 * 1024 * 1024) // 2MB mÃ¡ximo por ejecutable

// InformaciÃ³n de un ejecutable cargado
typedef struct {
  char path[VFS_PATH_MAX];
  void *code_base;
  uint32_t code_size;
  void *entry_point;
  uint32_t load_address; // DirecciÃ³n donde se cargÃ³ realmente
} exec_info_t;

// Funciones pÃºblicas
task_t *exec_load_and_run(const char *path);
void exec_test_program(const char *path);

#endif // EXEC_H



================================================================================
FILE: ahci.h
================================================================================

#ifndef AHCI_H
#define AHCI_H

#include "dma.h"
#include "pci.h"
#include <stdbool.h>
#include <stdint.h>

// AHCI PCI Class/Subclass
#define AHCI_PCI_CLASS 0x01    // Mass Storage
#define AHCI_PCI_SUBCLASS 0x06 // SATA
#define AHCI_PCI_PROG_IF 0x01  // AHCI

// AHCI Generic Host Control Registers
#define AHCI_HBA_CAP 0x00       // Host Capabilities
#define AHCI_HBA_GHC 0x04       // Global Host Control
#define AHCI_HBA_IS 0x08        // Interrupt Status
#define AHCI_HBA_PI 0x0C        // Port Implemented
#define AHCI_HBA_VS 0x10        // Version
#define AHCI_HBA_CCC_CTL 0x14   // Command Completion Coalescing Control
#define AHCI_HBA_CCC_PORTS 0x18 // Command Completion Coalescing Ports
#define AHCI_HBA_EM_LOC 0x1C    // Enclosure Management Location
#define AHCI_HBA_EM_CTL 0x20    // Enclosure Management Control
#define AHCI_HBA_CAP2 0x24      // Extended Host Capabilities
#define AHCI_HBA_BOHC 0x28      // BIOS/OS Handoff Control and Status

// AHCI Port Registers (each port has 0x80 bytes, starting at 0x100)
#define AHCI_PORT_BASE 0x100
#define AHCI_PORT_SIZE 0x80
#define AHCI_PORT_CLB 0x00  // Command List Base Address
#define AHCI_PORT_CLBU 0x04 // Command List Base Address Upper 32-bits
#define AHCI_PORT_FB 0x08   // FIS Base Address
#define AHCI_PORT_FBU 0x0C  // FIS Base Address Upper 32-bits
#define AHCI_PORT_IS 0x10   // Interrupt Status
#define AHCI_PORT_IE 0x14   // Interrupt Enable
#define AHCI_PORT_CMD 0x18  // Command and Status
#define AHCI_PORT_TFD 0x20  // Task File Data
#define AHCI_PORT_SIG 0x24  // Signature
#define AHCI_PORT_SSTS 0x28 // SATA Status (SCR0: SStatus)
#define AHCI_PORT_SCTL 0x2C // SATA Control (SCR2: SControl)
#define AHCI_PORT_SERR 0x30 // SATA Error (SCR1: SError)
#define AHCI_PORT_SACT 0x34 // SATA Active (SCR3: SActive)
#define AHCI_PORT_CI 0x38   // Command Issue

// Host Capabilities (CAP) register bits
#define AHCI_CAP_NP_MASK 0x1F  // Number of ports
#define AHCI_CAP_SXS (1 << 5)  // External SATA
#define AHCI_CAP_EMS (1 << 6)  // Enclosure Management
#define AHCI_CAP_CCCS (1 << 7) // Command Completion Coalescing
#define AHCI_CAP_NCS_SHIFT 8   // Number of Command Slots
#define AHCI_CAP_NCS_MASK 0x1F
#define AHCI_CAP_PSC (1 << 13)  // Partial State Capable
#define AHCI_CAP_SSC (1 << 14)  // Slumber State Capable
#define AHCI_CAP_PMD (1 << 15)  // PIO Multiple DRQ Block
#define AHCI_CAP_FBSS (1 << 16) // FIS-based Switching
#define AHCI_CAP_SPM (1 << 17)  // Port Multiplier
#define AHCI_CAP_SAM (1 << 18)  // AHCI mode only
#define AHCI_CAP_SNZO (1 << 19) // Non-Zero DMA Offsets
#define AHCI_CAP_ISS_SHIFT 20   // Interface Speed Support
#define AHCI_CAP_ISS_MASK 0xF
#define AHCI_CAP_SCLO (1 << 24)  // Command List Override
#define AHCI_CAP_SAL (1 << 25)   // Activity LED
#define AHCI_CAP_SALP (1 << 26)  // Aggressive Link Power Management
#define AHCI_CAP_SSS (1 << 27)   // Staggered Spin-up
#define AHCI_CAP_SMPS (1 << 28)  // Mechanical Presence Switch
#define AHCI_CAP_SSNTF (1 << 29) // SNotification Register
#define AHCI_CAP_SNCQ (1 << 30)  // Native Command Queuing
#define AHCI_CAP_S64A (1 << 31)  // 64-bit Addressing

// Global Host Control (GHC) register bits
#define AHCI_GHC_HR (1 << 0)   // HBA Reset
#define AHCI_GHC_IE (1 << 1)   // Interrupt Enable
#define AHCI_GHC_MRSM (1 << 2) // MSI Revert to Single Message
#define AHCI_GHC_AE (1 << 31)  // AHCI Enable

// Port Command (PxCMD) register bits
#define AHCI_PORT_CMD_ST (1 << 0)  // Start
#define AHCI_PORT_CMD_SUD (1 << 1) // Spin-Up Device
#define AHCI_PORT_CMD_POD (1 << 2) // Power On Device
#define AHCI_PORT_CMD_CLO (1 << 3) // Command List Override
#define AHCI_PORT_CMD_FRE (1 << 4) // FIS Receive Enable
#define AHCI_PORT_CMD_CCS_SHIFT 8  // Current Command Slot
#define AHCI_PORT_CMD_CCS_MASK 0x1F
#define AHCI_PORT_CMD_MPSS (1 << 13)  // Mechanical Presence Switch State
#define AHCI_PORT_CMD_FR (1 << 14)    // FIS Receive Running
#define AHCI_PORT_CMD_CR (1 << 15)    // Command List Running
#define AHCI_PORT_CMD_CPS (1 << 16)   // Cold Presence State
#define AHCI_PORT_CMD_PMA (1 << 17)   // Port Multiplier Attached
#define AHCI_PORT_CMD_HPCP (1 << 18)  // Hot Plug Capable Port
#define AHCI_PORT_CMD_MPSP (1 << 19)  // Mechanical Presence Switch
#define AHCI_PORT_CMD_CPD (1 << 20)   // Cold Presence Detection
#define AHCI_PORT_CMD_ESP (1 << 21)   // External SATA Port
#define AHCI_PORT_CMD_FBSCP (1 << 22) // FIS-based Switching Capable
#define AHCI_PORT_CMD_APSTE (1 << 23) // Automatic Partial to Slumber
#define AHCI_PORT_CMD_ATAPI (1 << 24) // Device is ATAPI
#define AHCI_PORT_CMD_DLAE (1 << 25)  // Drive LED on ATAPI Enable
#define AHCI_PORT_CMD_ALPE (1 << 26)  // Aggressive Link Power Management Enable
#define AHCI_PORT_CMD_ASP (1 << 27)   // Aggressive Slumber/Partial
#define AHCI_PORT_CMD_ICC_SHIFT 28    // Interface Communication Control
#define AHCI_PORT_CMD_ICC_MASK 0xF
#define AHCI_PORT_CMD_ICC_ACTIVE 0x1 // Interface Communication Control: Active

// Port Interrupt Status (PxIS) register bits
#define AHCI_PORT_IS_DHRS (1 << 0)  // Device to Host Register FIS Interrupt
#define AHCI_PORT_IS_PSS (1 << 1)   // PIO Setup FIS Interrupt
#define AHCI_PORT_IS_DSS (1 << 2)   // DMA Setup FIS Interrupt
#define AHCI_PORT_IS_SDBS (1 << 3)  // Set Device Bits Interrupt
#define AHCI_PORT_IS_UFS (1 << 4)   // Unknown FIS Interrupt
#define AHCI_PORT_IS_DPS (1 << 5)   // Descriptor Processed
#define AHCI_PORT_IS_PCS (1 << 6)   // Port Connect Change Status
#define AHCI_PORT_IS_DMPS (1 << 7)  // Device Mechanical Presence Status
#define AHCI_PORT_IS_PRCS (1 << 22) // PhyRdy Change Status
#define AHCI_PORT_IS_IPMS (1 << 23) // Incorrect Port Multiplier Status
#define AHCI_PORT_IS_OFS (1 << 24)  // Overflow Status
#define AHCI_PORT_IS_INFS (1 << 26) // Interface Non-fatal Error Status
#define AHCI_PORT_IS_IFS (1 << 27)  // Interface Fatal Error Status
#define AHCI_PORT_IS_HBDS (1 << 28) // Host Bus Data Error Status
#define AHCI_PORT_IS_HBFS (1 << 29) // Host Bus Fatal Error Status
#define AHCI_PORT_IS_TFES (1 << 30) // Task File Error Status
#define AHCI_PORT_IS_CPDS (1 << 31) // Cold Port Detect Status

// SATA Status (PxSSTS) register bits
#define AHCI_PORT_SSTS_DET_MASK 0x0000000F // Device Detection
#define AHCI_PORT_SSTS_SPD_SHIFT 4         // Current Interface Speed
#define AHCI_PORT_SSTS_SPD_MASK 0xF
#define AHCI_PORT_SSTS_IPM_SHIFT 8 // Interface Power Management
#define AHCI_PORT_SSTS_IPM_MASK 0xF
#define AHCI_PORT_SSTS_DET_PRESENT 0x00000003
#define AHCI_PORT_SSTS_IPM_ACTIVE 0x00000001

// ATA Status Register bits
#define ATA_SR_BSY (1 << 7)
#define ATA_SR_DRQ (1 << 3)
#define ATA_SR_ERR (1 << 0)
#define ATA_SR_DF (1 << 5)

// Device Detection values
#define AHCI_PORT_DET_NONE 0x0        // No device detected
#define AHCI_PORT_DET_PRESENT 0x1     // Device present but not established
#define AHCI_PORT_DET_ESTABLISHED 0x3 // Device present and established

// Interface Speed values
#define AHCI_PORT_SPD_NONE 0x0
#define AHCI_PORT_SPD_GEN1 0x1 // 1.5 Gbps
#define AHCI_PORT_SPD_GEN2 0x2 // 3.0 Gbps
#define AHCI_PORT_SPD_GEN3 0x3 // 6.0 Gbps

// SATA signatures
#define AHCI_SIG_ATA 0x00000101   // SATA drive
#define AHCI_SIG_ATAPI 0xEB140101 // ATAPI drive
#define AHCI_SIG_SEMB 0xC33C0101  // Enclosure management bridge
#define AHCI_SIG_PM 0x96690101    // Port multiplier

// FIS Types
#define FIS_TYPE_REG_H2D 0x27   // Register FIS - host to device
#define FIS_TYPE_REG_D2H 0x34   // Register FIS - device to host
#define FIS_TYPE_DMA_ACT 0x39   // DMA activate FIS
#define FIS_TYPE_DMA_SETUP 0x41 // DMA setup FIS
#define FIS_TYPE_DATA 0x46      // Data FIS
#define FIS_TYPE_BIST 0x58      // BIST activate FIS
#define FIS_TYPE_PIO_SETUP 0x5F // PIO setup FIS
#define FIS_TYPE_DEV_BITS 0xA1  // Set device bits FIS

// ATA Commands
#define ATA_CMD_READ_DMA 0xC8
#define ATA_CMD_READ_DMA_EXT 0x25
#define ATA_CMD_WRITE_DMA 0xCA
#define ATA_CMD_WRITE_DMA_EXT 0x35
#define ATA_CMD_IDENTIFY 0xEC
#define ATA_CMD_IDENTIFY_PACKET 0xA1

// Command slot and FIS sizes
#define AHCI_MAX_PORTS 32
#define AHCI_MAX_CMDS 32
#define AHCI_CMD_SLOT_SIZE 32
#define AHCI_RX_FIS_SIZE 256
#define AHCI_CMD_TBL_SIZE 0x80

#define AHCI_PORT_IE_MASK                                                      \
  (AHCI_PORT_IS_DHRS | AHCI_PORT_IS_PSS | AHCI_PORT_IS_DSS |                   \
   AHCI_PORT_IS_SDBS | AHCI_PORT_IS_UFS | AHCI_PORT_IS_TFES |                  \
   AHCI_PORT_IS_PCS | AHCI_PORT_IS_PRCS)

// Structure definitions
typedef struct __attribute__((packed)) {
  // DWORD 0
  uint8_t fis_type;
  uint8_t pmport : 4;
  uint8_t rsv0 : 3;
  uint8_t c : 1;
  uint8_t command;
  uint8_t featurel;

  // DWORD 1
  uint8_t lba0;
  uint8_t lba1;
  uint8_t lba2;
  uint8_t device;

  // DWORD 2
  uint8_t lba3;
  uint8_t lba4;
  uint8_t lba5;
  uint8_t featureh;

  // DWORD 3
  uint8_t countl;
  uint8_t counth;
  uint8_t icc;
  uint8_t control;

  // DWORD 4
  uint8_t rsv1[4];
} fis_reg_h2d_t;

typedef struct __attribute__((packed)) {
  // DWORD 0
  uint8_t fis_type;
  uint8_t pmport : 4;
  uint8_t rsv0 : 2;
  uint8_t i : 1;
  uint8_t rsv1 : 1;
  uint8_t status;
  uint8_t error;

  // DWORD 1
  uint8_t lba0;
  uint8_t lba1;
  uint8_t lba2;
  uint8_t device;

  // DWORD 2
  uint8_t lba3;
  uint8_t lba4;
  uint8_t lba5;
  uint8_t rsv2;

  // DWORD 3
  uint8_t countl;
  uint8_t counth;
  uint8_t rsv3[2];

  // DWORD 4
  uint8_t rsv4[4];
} fis_reg_d2h_t;

typedef struct __attribute__((packed)) {
  // DWORD 0
  uint32_t cfl : 5;    // Command FIS length in DWORDS, 2 ~ 16
  uint32_t a : 1;      // ATAPI
  uint32_t w : 1;      // Write, 1: H2D, 0: D2H
  uint32_t p : 1;      // Prefetchable
  uint32_t r : 1;      // Reset
  uint32_t b : 1;      // BIST
  uint32_t c : 1;      // Clear busy upon R_OK
  uint32_t rsv0 : 1;   // Reserved
  uint32_t pmp : 4;    // Port multiplier port
  uint32_t prdtl : 16; // Physical region descriptor table length

  // DWORD 1
  volatile uint32_t prdbc; // Physical region descriptor byte count

  // DWORD 2, 3
  uint32_t ctba;  // Command table descriptor base address
  uint32_t ctbau; // Command table descriptor base address upper 32 bits

  // DWORD 4 - 7
  uint32_t rsv1[4]; // Reserved
} hba_cmd_header_t;

typedef struct __attribute__((packed)) {
  uint32_t dba;      // Data base address
  uint32_t dbau;     // Data base address upper 32 bits
  uint32_t rsv0;     // Reserved
  uint32_t dbc : 22; // Byte count, 4M max
  uint32_t rsv1 : 9; // Reserved
  uint32_t i : 1;    // Interrupt on completion
} hba_prdt_entry_t;

typedef struct __attribute__((packed)) {
  uint8_t cfis[64];               // Command FIS
  uint8_t acmd[16];               // ATAPI command, 12 or 16 bytes
  uint8_t rsv[48];                // Reserved
  hba_prdt_entry_t prdt_entry[1]; // Physical region descriptor table entries
} hba_cmd_tbl_t;

typedef struct __attribute__((packed)) {
  // 0x00 - 0x2B, Generic Host Control
  volatile uint32_t cap;     // 0x00, Host capability
  volatile uint32_t ghc;     // 0x04, Global host control
  volatile uint32_t is;      // 0x08, Interrupt status
  volatile uint32_t pi;      // 0x0C, Port implemented
  volatile uint32_t vs;      // 0x10, Version
  volatile uint32_t ccc_ctl; // 0x14, Command completion coalescing control
  volatile uint32_t ccc_pts; // 0x18, Command completion coalescing ports
  volatile uint32_t em_loc;  // 0x1C, Enclosure management location
  volatile uint32_t em_ctl;  // 0x20, Enclosure management control
  volatile uint32_t cap2;    // 0x24, Host capabilities extended
  volatile uint32_t bohc;    // 0x28, BIOS/OS handoff control and status

  // 0x2C - 0x9F, Reserved
  uint8_t rsv[0xA0 - 0x2C];

  // 0xA0 - 0xFF, Vendor specific registers
  uint8_t vendor[0x100 - 0xA0];
} hba_mem_t;

typedef struct __attribute__((packed)) {
  volatile uint32_t clb;  // 0x00, command list base address, 1K-byte aligned
  volatile uint32_t clbu; // 0x04, command list base address upper 32 bits
  volatile uint32_t fb;   // 0x08, FIS base address, 256-byte aligned
  volatile uint32_t fbu;  // 0x0C, FIS base address upper 32 bits
  volatile uint32_t is;   // 0x10, interrupt status
  volatile uint32_t ie;   // 0x14, interrupt enable
  volatile uint32_t cmd;  // 0x18, command and status
  volatile uint32_t rsv0; // 0x1C, Reserved
  volatile uint32_t tfd;  // 0x20, task file data
  volatile uint32_t sig;  // 0x24, signature
  volatile uint32_t ssts; // 0x28, SATA status (SCR0:SStatus)
  volatile uint32_t sctl; // 0x2C, SATA control (SCR2:SControl)
  volatile uint32_t serr; // 0x30, SATA error (SCR1:SError)
  volatile uint32_t sact; // 0x34, SATA active (SCR3:SActive)
  volatile uint32_t ci;   // 0x38, command issue
  volatile uint32_t sntf; // 0x3C, SATA notification (SCR4:SNotification)
  volatile uint32_t fbs;  // 0x40, FIS-based switch control
  volatile uint32_t rsv1[11];  // 0x44 ~ 0x6F, Reserved
  volatile uint32_t vendor[4]; // 0x70 ~ 0x7F, vendor specific
} hba_port_t;

// AHCI Port structure
typedef struct {
  uint8_t port_num;
  bool present;
  bool initialized;
  uint8_t device_type; // ATA, ATAPI, etc
  uint32_t signature;

  hba_port_t *port_regs;
  hba_cmd_header_t *cmd_list;
  uint8_t *fis_base;
  hba_cmd_tbl_t *cmd_tables[AHCI_MAX_CMDS];

  dma_buffer_t *cmd_list_buffer;
  dma_buffer_t *fis_buffer;
  dma_buffer_t *cmd_table_buffers[AHCI_MAX_CMDS];

  bool command_slots[AHCI_MAX_CMDS]; // Track used slots
} ahci_port_t;

// AHCI Controller structure
typedef struct {
  bool initialized;
  pci_device_t *pci_device;
  hba_mem_t *abar; // AHCI Base Address Register
  uint32_t abar_physical;

  uint32_t port_count;
  uint32_t command_slots;
  bool supports_64bit;
  bool supports_ncq;

  ahci_port_t ports[AHCI_MAX_PORTS];
  uint32_t ports_implemented;
} ahci_controller_t;

// Global AHCI controller
extern ahci_controller_t ahci_controller;

// Function prototypes
bool ahci_init(void);
void ahci_cleanup(void);
bool ahci_detect_controller(void);
bool ahci_initialize_controller(void);
bool ahci_initialize_port(uint8_t port_num);
bool ahci_spin_up_device(uint8_t port_num);
bool ahci_start_port(uint8_t port_num);
bool ahci_stop_port(uint8_t port_num);

// Command functions
int ahci_find_cmdslot(ahci_port_t *port);
bool ahci_send_command(uint8_t port_num, uint8_t slot, uint8_t *fis,
                       void *buffer, uint32_t buffer_size, bool write);
bool ahci_identify_device(uint8_t port_num, void *buffer);
bool ahci_identify_device_pio(uint8_t port_num, void *buffer);
bool ahci_read_sectors(uint8_t port_num, uint64_t lba, uint32_t count,
                       void *buffer);
bool ahci_write_sectors(uint8_t port_num, uint64_t lba, uint32_t count,
                        const void *buffer);

// Utility functions
void ahci_list_devices(void);
void ahci_print_port_status(uint8_t port_num);
const char *ahci_get_device_type_name(uint32_t signature);

// Forward declaration
struct regs;

// IRQ handler
void ahci_irq_handler(struct regs *r);

#endif // AHCI_H



================================================================================
FILE: stdarg.h
================================================================================

#ifndef _STDARG_H
#define _STDARG_H

typedef __builtin_va_list va_list;

#define va_start(v, l) __builtin_va_start(v, l)
#define va_arg(v, l) __builtin_va_arg(v, l)
#define va_end(v) __builtin_va_end(v)
#define va_copy(d, s) __builtin_va_copy(d, s)

#endif



================================================================================
FILE: usb_mass_storage.h
================================================================================

#ifndef USB_MASS_STORAGE_H
#define USB_MASS_STORAGE_H

#include "usb_core.h"
#include <stdint.h>
#include <stdbool.h>

// Mass Storage Class Codes
#define USB_MSC_SUBCLASS_SCSI       0x06  // SCSI Transparent
#define USB_MSC_PROTOCOL_BBB        0x50  // Bulk-Only Transport (BOT)

// SCSI Commands
#define SCSI_CMD_TEST_UNIT_READY    0x00
#define SCSI_CMD_REQUEST_SENSE      0x03
#define SCSI_CMD_INQUIRY            0x12
#define SCSI_CMD_READ_CAPACITY_10   0x25
#define SCSI_CMD_READ_10            0x28
#define SCSI_CMD_WRITE_10           0x2A

// CBW (Command Block Wrapper)
#define CBW_SIGNATURE               0x43425355  // "USBC"
#define CBW_FLAG_DATA_IN            0x80
#define CBW_FLAG_DATA_OUT           0x00

// CSW (Command Status Wrapper)
#define CSW_SIGNATURE               0x53425355  // "USBS"
#define CSW_STATUS_GOOD             0x00
#define CSW_STATUS_FAILED           0x01
#define CSW_STATUS_PHASE_ERROR      0x02

#define USB_MSC_MAX_DEVICES         8

// Command Block Wrapper
typedef struct __attribute__((packed)) {
    uint32_t dCBWSignature;
    uint32_t dCBWTag;
    uint32_t dCBWDataTransferLength;
    uint8_t  bmCBWFlags;
    uint8_t  bCBWLUN;
    uint8_t  bCBWCBLength;
    uint8_t  CBWCB[16];
} usb_msc_cbw_t;

// Command Status Wrapper
typedef struct __attribute__((packed)) {
    uint32_t dCSWSignature;
    uint32_t dCSWTag;
    uint32_t dCSWDataResidue;
    uint8_t  bCSWStatus;
} usb_msc_csw_t;

// SCSI Inquiry Response
typedef struct __attribute__((packed)) {
    uint8_t  peripheral_device_type;
    uint8_t  removable;
    uint8_t  version;
    uint8_t  response_data_format;
    uint8_t  additional_length;
    uint8_t  flags[3];
    uint8_t  vendor_id[8];
    uint8_t  product_id[16];
    uint8_t  revision[4];
} scsi_inquiry_response_t;

// SCSI Read Capacity Response
typedef struct __attribute__((packed)) {
    uint32_t last_lba;
    uint32_t block_size;
} scsi_read_capacity_response_t;

// USB Mass Storage Device
typedef struct {
    usb_device_t* usb_device;
    uint8_t ep_in;
    uint8_t ep_out;
    uint8_t max_lun;
    
    uint32_t block_count;
    uint32_t block_size;
    
    uint32_t tag_counter;
    bool initialized;
} usb_msc_device_t;

// Global array of mass storage devices
extern usb_msc_device_t usb_msc_devices[USB_MSC_MAX_DEVICES];
extern uint8_t usb_msc_device_count;

// Driver registration
void usb_msc_register_driver(void);

// Device management
bool usb_msc_probe(usb_device_t* device);
bool usb_msc_init(usb_device_t* device);
void usb_msc_cleanup(usb_device_t* device);

// SCSI operations
bool usb_msc_inquiry(usb_msc_device_t* msc);
bool usb_msc_test_unit_ready(usb_msc_device_t* msc);
bool usb_msc_read_capacity(usb_msc_device_t* msc);
bool usb_msc_read_blocks(usb_msc_device_t* msc, uint32_t lba, uint16_t count, void* buffer);
bool usb_msc_write_blocks(usb_msc_device_t* msc, uint32_t lba, uint16_t count, const void* buffer);

// Utility functions
void usb_msc_list_devices(void);
usb_msc_device_t* usb_msc_get_device(uint8_t index);
uint8_t usb_msc_get_device_count(void);

#endif // USB_MASS_STORAGE_H



================================================================================
FILE: multiboot2.h
================================================================================

/*   multiboot2.h - Multiboot 2 header file. */
/*   Copyright (C) 1999,2003,2007,2008,2009,2010  Free Software Foundation, Inc.
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the "Software"), to
 *  deal in the Software without restriction, including without limitation the
 *  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 *  sell copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL ANY
 *  DEVELOPER OR DISTRIBUTOR BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 *  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 *  IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef MULTIBOOT_HEADER
#define MULTIBOOT_HEADER 1

/*  How many bytes from the start of the file we search for the header. */
#define MULTIBOOT_SEARCH                        32768
#define MULTIBOOT_HEADER_ALIGN                  8

/*  The magic field should contain this. */
#define MULTIBOOT2_HEADER_MAGIC                 0xe85250d6

/*  This should be in %eax. */
#define MULTIBOOT2_BOOTLOADER_MAGIC             0x36d76289

/*  Alignment of multiboot modules. */
#define MULTIBOOT_MOD_ALIGN                     0x00001000

/*  Alignment of the multiboot info structure. */
#define MULTIBOOT_INFO_ALIGN                    0x00000008

/*  Flags set in the â€™flagsâ€™ member of the multiboot header. */

#define MULTIBOOT_TAG_ALIGN                  8
#define MULTIBOOT_TAG_TYPE_END               0
#define MULTIBOOT_TAG_TYPE_CMDLINE           1
#define MULTIBOOT_TAG_TYPE_BOOT_LOADER_NAME  2
#define MULTIBOOT_TAG_TYPE_MODULE            3
#define MULTIBOOT_TAG_TYPE_BASIC_MEMINFO     4
#define MULTIBOOT_TAG_TYPE_BOOTDEV           5
#define MULTIBOOT_TAG_TYPE_MMAP              6
#define MULTIBOOT_TAG_TYPE_VBE               7
#define MULTIBOOT_TAG_TYPE_FRAMEBUFFER       8
#define MULTIBOOT_TAG_TYPE_ELF_SECTIONS      9
#define MULTIBOOT_TAG_TYPE_APM               10
#define MULTIBOOT_TAG_TYPE_EFI32             11
#define MULTIBOOT_TAG_TYPE_EFI64             12
#define MULTIBOOT_TAG_TYPE_SMBIOS            13
#define MULTIBOOT_TAG_TYPE_ACPI_OLD          14
#define MULTIBOOT_TAG_TYPE_ACPI_NEW          15
#define MULTIBOOT_TAG_TYPE_NETWORK           16
#define MULTIBOOT_TAG_TYPE_EFI_MMAP          17
#define MULTIBOOT_TAG_TYPE_EFI_BS            18
#define MULTIBOOT_TAG_TYPE_EFI32_IH          19
#define MULTIBOOT_TAG_TYPE_EFI64_IH          20
#define MULTIBOOT_TAG_TYPE_LOAD_BASE_ADDR    21

#define MULTIBOOT_HEADER_TAG_END  0
#define MULTIBOOT_HEADER_TAG_INFORMATION_REQUEST  1
#define MULTIBOOT_HEADER_TAG_ADDRESS  2
#define MULTIBOOT_HEADER_TAG_ENTRY_ADDRESS  3
#define MULTIBOOT_HEADER_TAG_CONSOLE_FLAGS  4
#define MULTIBOOT_HEADER_TAG_FRAMEBUFFER  5
#define MULTIBOOT_HEADER_TAG_MODULE_ALIGN  6
#define MULTIBOOT_HEADER_TAG_EFI_BS        7
#define MULTIBOOT_HEADER_TAG_ENTRY_ADDRESS_EFI32  8
#define MULTIBOOT_HEADER_TAG_ENTRY_ADDRESS_EFI64  9
#define MULTIBOOT_HEADER_TAG_RELOCATABLE  10

#define MULTIBOOT_ARCHITECTURE_I386  0
#define MULTIBOOT_ARCHITECTURE_MIPS32  4
#define MULTIBOOT_HEADER_TAG_OPTIONAL 1

#define MULTIBOOT_LOAD_PREFERENCE_NONE 0
#define MULTIBOOT_LOAD_PREFERENCE_LOW 1
#define MULTIBOOT_LOAD_PREFERENCE_HIGH 2

#define MULTIBOOT_CONSOLE_FLAGS_CONSOLE_REQUIRED 1
#define MULTIBOOT_CONSOLE_FLAGS_EGA_TEXT_SUPPORTED 2

#ifndef ASM_FILE

typedef unsigned char           multiboot_uint8_t;
typedef unsigned short          multiboot_uint16_t;
typedef unsigned int            multiboot_uint32_t;
typedef unsigned long long      multiboot_uint64_t;

struct multiboot_header
{
  /*  Must be MULTIBOOT_MAGIC - see above. */
  multiboot_uint32_t magic;

  /*  ISA */
  multiboot_uint32_t architecture;

  /*  Total header length. */
  multiboot_uint32_t header_length;

  /*  The above fields plus this one must equal 0 mod 2^32. */
  multiboot_uint32_t checksum;
};

struct multiboot_header_tag
{
  multiboot_uint16_t type;
  multiboot_uint16_t flags;
  multiboot_uint32_t size;
};

struct multiboot_header_tag_information_request
{
  multiboot_uint16_t type;
  multiboot_uint16_t flags;
  multiboot_uint32_t size;
  multiboot_uint32_t requests[0];
};

struct multiboot_header_tag_address
{
  multiboot_uint16_t type;
  multiboot_uint16_t flags;
  multiboot_uint32_t size;
  multiboot_uint32_t header_addr;
  multiboot_uint32_t load_addr;
  multiboot_uint32_t load_end_addr;
  multiboot_uint32_t bss_end_addr;
};

struct multiboot_header_tag_entry_address
{
  multiboot_uint16_t type;
  multiboot_uint16_t flags;
  multiboot_uint32_t size;
  multiboot_uint32_t entry_addr;
};

struct multiboot_header_tag_console_flags
{
  multiboot_uint16_t type;
  multiboot_uint16_t flags;
  multiboot_uint32_t size;
  multiboot_uint32_t console_flags;
};

struct multiboot_header_tag_framebuffer
{
  multiboot_uint16_t type;
  multiboot_uint16_t flags;
  multiboot_uint32_t size;
  multiboot_uint32_t width;
  multiboot_uint32_t height;
  multiboot_uint32_t depth;
};

struct multiboot_header_tag_module_align
{
  multiboot_uint16_t type;
  multiboot_uint16_t flags;
  multiboot_uint32_t size;
};

struct multiboot_header_tag_relocatable
{
  multiboot_uint16_t type;
  multiboot_uint16_t flags;
  multiboot_uint32_t size;
  multiboot_uint32_t min_addr;
  multiboot_uint32_t max_addr;
  multiboot_uint32_t align;
  multiboot_uint32_t preference;
};

struct multiboot_color
{
  multiboot_uint8_t red;
  multiboot_uint8_t green;
  multiboot_uint8_t blue;
};

struct multiboot_mmap_entry
{
  multiboot_uint64_t addr;
  multiboot_uint64_t len;
#define MULTIBOOT_MEMORY_AVAILABLE              1
#define MULTIBOOT_MEMORY_RESERVED               2
#define MULTIBOOT_MEMORY_ACPI_RECLAIMABLE       3
#define MULTIBOOT_MEMORY_NVS                    4
#define MULTIBOOT_MEMORY_BADRAM                 5
  multiboot_uint32_t type;
  multiboot_uint32_t zero;
};
typedef struct multiboot_mmap_entry multiboot_memory_map_t;

struct multiboot_tag
{
  multiboot_uint32_t type;
  multiboot_uint32_t size;
};

struct multiboot_tag_string
{
  multiboot_uint32_t type;
  multiboot_uint32_t size;
  char string[0];
};

struct multiboot_tag_module
{
  multiboot_uint32_t type;
  multiboot_uint32_t size;
  multiboot_uint32_t mod_start;
  multiboot_uint32_t mod_end;
  char cmdline[0];
};

struct multiboot_tag_basic_meminfo
{
  multiboot_uint32_t type;
  multiboot_uint32_t size;
  multiboot_uint32_t mem_lower;
  multiboot_uint32_t mem_upper;
};

struct multiboot_tag_bootdev
{
  multiboot_uint32_t type;
  multiboot_uint32_t size;
  multiboot_uint32_t biosdev;
  multiboot_uint32_t slice;
  multiboot_uint32_t part;
};

struct multiboot_tag_mmap
{
  multiboot_uint32_t type;
  multiboot_uint32_t size;
  multiboot_uint32_t entry_size;
  multiboot_uint32_t entry_version;
  struct multiboot_mmap_entry entries[0];  
};

struct multiboot_vbe_info_block
{
  multiboot_uint8_t external_specification[512];
};

struct multiboot_vbe_mode_info_block
{
  multiboot_uint8_t external_specification[256];
};

struct multiboot_tag_vbe
{
  multiboot_uint32_t type;
  multiboot_uint32_t size;

  multiboot_uint16_t vbe_mode;
  multiboot_uint16_t vbe_interface_seg;
  multiboot_uint16_t vbe_interface_off;
  multiboot_uint16_t vbe_interface_len;

  struct multiboot_vbe_info_block vbe_control_info;
  struct multiboot_vbe_mode_info_block vbe_mode_info;
};

struct multiboot_tag_framebuffer_common
{
  multiboot_uint32_t type;
  multiboot_uint32_t size;

  multiboot_uint64_t framebuffer_addr;
  multiboot_uint32_t framebuffer_pitch;
  multiboot_uint32_t framebuffer_width;
  multiboot_uint32_t framebuffer_height;
  multiboot_uint8_t framebuffer_bpp;
#define MULTIBOOT_FRAMEBUFFER_TYPE_INDEXED 0
#define MULTIBOOT_FRAMEBUFFER_TYPE_RGB     1
#define MULTIBOOT_FRAMEBUFFER_TYPE_EGA_TEXT     2
  multiboot_uint8_t framebuffer_type;
  multiboot_uint16_t reserved;
};

struct multiboot_tag_framebuffer
{
  struct multiboot_tag_framebuffer_common common;

  union
  {
    struct
    {
      multiboot_uint16_t framebuffer_palette_num_colors;
      struct multiboot_color framebuffer_palette[0];
    };
    struct
    {
      multiboot_uint8_t framebuffer_red_field_position;
      multiboot_uint8_t framebuffer_red_mask_size;
      multiboot_uint8_t framebuffer_green_field_position;
      multiboot_uint8_t framebuffer_green_mask_size;
      multiboot_uint8_t framebuffer_blue_field_position;
      multiboot_uint8_t framebuffer_blue_mask_size;
    };
  };
};

struct multiboot_tag_elf_sections
{
  multiboot_uint32_t type;
  multiboot_uint32_t size;
  multiboot_uint32_t num;
  multiboot_uint32_t entsize;
  multiboot_uint32_t shndx;
  char sections[0];
};

struct multiboot_tag_apm
{
  multiboot_uint32_t type;
  multiboot_uint32_t size;
  multiboot_uint16_t version;
  multiboot_uint16_t cseg;
  multiboot_uint32_t offset;
  multiboot_uint16_t cseg_16;
  multiboot_uint16_t dseg;
  multiboot_uint16_t flags;
  multiboot_uint16_t cseg_len;
  multiboot_uint16_t cseg_16_len;
  multiboot_uint16_t dseg_len;
};

struct multiboot_tag_efi32
{
  multiboot_uint32_t type;
  multiboot_uint32_t size;
  multiboot_uint32_t pointer;
};

struct multiboot_tag_efi64
{
  multiboot_uint32_t type;
  multiboot_uint32_t size;
  multiboot_uint64_t pointer;
};

struct multiboot_tag_smbios
{
  multiboot_uint32_t type;
  multiboot_uint32_t size;
  multiboot_uint8_t major;
  multiboot_uint8_t minor;
  multiboot_uint8_t reserved[6];
  multiboot_uint8_t tables[0];
};

struct multiboot_tag_old_acpi
{
  multiboot_uint32_t type;
  multiboot_uint32_t size;
  multiboot_uint8_t rsdp[0];
};

struct multiboot_tag_new_acpi
{
  multiboot_uint32_t type;
  multiboot_uint32_t size;
  multiboot_uint8_t rsdp[0];
};

struct multiboot_tag_network
{
  multiboot_uint32_t type;
  multiboot_uint32_t size;
  multiboot_uint8_t dhcpack[0];
};

struct multiboot_tag_efi_mmap
{
  multiboot_uint32_t type;
  multiboot_uint32_t size;
  multiboot_uint32_t descr_size;
  multiboot_uint32_t descr_vers;
  multiboot_uint8_t efi_mmap[0];
}; 

struct multiboot_tag_efi32_ih
{
  multiboot_uint32_t type;
  multiboot_uint32_t size;
  multiboot_uint32_t pointer;
};

struct multiboot_tag_efi64_ih
{
  multiboot_uint32_t type;
  multiboot_uint32_t size;
  multiboot_uint64_t pointer;
};

struct multiboot_tag_load_base_addr
{
  multiboot_uint32_t type;
  multiboot_uint32_t size;
  multiboot_uint32_t load_base_addr;
};

#endif /*  ! ASM_FILE */

#endif /*  ! MULTIBOOT_HEADER */



================================================================================
FILE: sata_disk.h
================================================================================

#ifndef SATA_DISK_H
#define SATA_DISK_H

#include "disk.h"
#include "dma.h"
#include <stdbool.h>
#include <stdint.h>


#define MAX_SATA_DISKS 8
#define SECTOR_SIZE 512
#define SATA_IO_BUFFER_SIZE (128 * 1024) // 64KB buffer for I/O

extern bool sata_initialized;

// SATA Error codes
typedef enum {
  SATA_ERR_NONE = 0,
  SATA_ERR_INVALID_PARAM,
  SATA_ERR_NOT_INITIALIZED,
  SATA_ERR_IO_ERROR,
  SATA_ERR_TIMEOUT,
  SATA_ERR_LBA_OUT_OF_RANGE,
  SATA_ERR_NO_MEMORY,
  SATA_ERR_DEVICE_NOT_READY
} sata_err_t;

// SATA Disk structure
typedef struct {
  uint8_t ahci_port; // AHCI port number
  bool present;      // Device present
  bool initialized;  // Device initialized

  // Device information
  char model[41];           // Device model string
  char serial[21];          // Device serial number
  uint64_t sector_count;    // Total sectors (LBA48 or LBA28)
  uint32_t sector_count_28; // LBA28 sector count

  // Capabilities
  bool supports_lba48; // LBA48 support
  bool supports_dma;   // DMA support
  bool supports_ncq;   // Native Command Queuing

  // I/O Buffer
  dma_buffer_t *io_buffer; // DMA buffer for I/O operations

  // Statistics
  uint64_t read_count;  // Number of read operations
  uint64_t write_count; // Number of write operations
  uint64_t error_count; // Number of errors
} sata_disk_t;

// Function prototypes

// Initialization and cleanup
bool sata_disk_init(void);
void sata_disk_cleanup(void);
bool sata_disk_setup(sata_disk_t *disk, uint8_t ahci_port);

// Disk operations
sata_err_t sata_disk_read(uint32_t disk_id, uint64_t lba, uint32_t count,
                          void *buffer);
sata_err_t sata_disk_write(uint32_t disk_id, uint64_t lba, uint32_t count,
                           const void *buffer);
sata_err_t sata_disk_flush(uint32_t disk_id);

// Information and utilities
uint32_t sata_disk_get_count(void);
sata_disk_t *sata_disk_get_info(uint32_t disk_id);
uint64_t sata_disk_get_sector_count(uint32_t disk_id);
bool sata_disk_is_present(uint32_t disk_id);
void sata_disk_list(void);

// Legacy disk interface compatibility
disk_err_t sata_to_legacy_disk_init(disk_t *disk, uint32_t sata_disk_id);
disk_err_t sata_to_legacy_disk_read(disk_t *disk, uint64_t lba, uint32_t count,
                                    void *buffer);
disk_err_t sata_to_legacy_disk_write(disk_t *disk, uint64_t lba, uint32_t count,
                                     const void *buffer);

// Testing
bool sata_disk_test(uint32_t disk_id);
void sata_disk_debug_port(uint8_t port_num);

#endif // SATA_DISK_H



================================================================================
FILE: acpi.h
================================================================================

#ifndef ACPI_H
#define ACPI_H

#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

// ACPI Signatures
#define ACPI_RSDP_SIGNATURE     "RSD PTR "
#define ACPI_RSDT_SIGNATURE     "RSDT"
#define ACPI_XSDT_SIGNATURE     "XSDT"
#define ACPI_FADT_SIGNATURE     "FACP"
#define ACPI_DSDT_SIGNATURE     "DSDT"
#define ACPI_SSDT_SIGNATURE     "SSDT"
#define ACPI_MADT_SIGNATURE     "APIC"
#define ACPI_MCFG_SIGNATURE     "MCFG"
#define ACPI_HPET_SIGNATURE     "HPET"

// ACPI Power Management 1 Control Register bits
#define ACPI_PM1_CNT_SCI_EN     (1 << 0)   // SCI interrupt enable
#define ACPI_PM1_CNT_BM_RLD     (1 << 1)   // Bus master reload
#define ACPI_PM1_CNT_GBL_RLS    (1 << 2)   // Global release
#define ACPI_PM1_CNT_SLP_TYP    (7 << 10)  // Sleep type mask
#define ACPI_PM1_CNT_SLP_EN     (1 << 13)  // Sleep enable

// Sleep states
#define ACPI_S0_SLEEP_TYPE      0x00        // Working state
#define ACPI_S1_SLEEP_TYPE      0x01        // Sleep with CPU and RAM on
#define ACPI_S3_SLEEP_TYPE      0x05        // Suspend to RAM
#define ACPI_S4_SLEEP_TYPE      0x06        // Suspend to disk
#define ACPI_S5_SLEEP_TYPE      0x07        // Soft power off

// Maximum number of ACPI tables to handle
#define MAX_ACPI_TABLES 32

// Root System Description Pointer (RSDP)
typedef struct __attribute__((packed)) {
    char signature[8];          // "RSD PTR "
    uint8_t checksum;           // Checksum of first 20 bytes
    char oem_id[6];            // OEM ID
    uint8_t revision;          // ACPI revision (0 = v1.0, 2 = v2.0+)
    uint32_t rsdt_address;     // Physical address of RSDT
    
    // ACPI 2.0+ fields
    uint32_t length;           // Length of RSDP structure
    uint64_t xsdt_address;     // Physical address of XSDT (64-bit)
    uint8_t extended_checksum; // Checksum of entire structure
    uint8_t reserved[3];       // Reserved fields
} acpi_rsdp_t;

// System Description Table Header (common to all tables)
typedef struct __attribute__((packed)) {
    char signature[4];         // Table signature
    uint32_t length;          // Length of table including header
    uint8_t revision;         // Table revision
    uint8_t checksum;         // Checksum of entire table
    char oem_id[6];          // OEM ID
    char oem_table_id[8];    // OEM Table ID
    uint32_t oem_revision;   // OEM Revision
    uint32_t creator_id;     // Creator ID
    uint32_t creator_revision; // Creator revision
} acpi_sdt_header_t;

// Root System Description Table (RSDT) - ACPI 1.0
typedef struct __attribute__((packed)) {
    acpi_sdt_header_t header;
    uint32_t sdt_pointers[]; // Variable length array of SDT pointers
} acpi_rsdt_t;

// Extended System Description Table (XSDT) - ACPI 2.0+
typedef struct __attribute__((packed)) {
    acpi_sdt_header_t header;
    uint64_t sdt_pointers[]; // Variable length array of 64-bit SDT pointers
} acpi_xsdt_t;

typedef struct __attribute__((packed)) {
    uint8_t address_space_id;    // 0: System Memory, 1: System I/O, 2: PCI Config, etc.
    uint8_t register_bit_width;
    uint8_t register_bit_offset;
    uint8_t access_size;         // 0: Undefined, 1: Byte, 2: Word, 3: DWord, 4: QWord
    uint64_t address;
} generic_address_t;

// Fixed ACPI Description Table (FADT)
typedef struct __attribute__((packed)) {
    acpi_sdt_header_t header;
    uint32_t firmware_ctrl;    // Physical address of FACS
    uint32_t dsdt_address;     // Physical address of DSDT
    uint8_t reserved1;         // Reserved
    uint8_t preferred_pm_profile; // Power management profile
    uint16_t sci_interrupt;    // SCI interrupt number
    uint32_t smi_command_port; // SMI command port
    uint8_t acpi_enable;       // Value to write to enable ACPI
    uint8_t acpi_disable;      // Value to write to disable ACPI
    uint8_t s4bios_req;        // Value for S4BIOS request
    uint8_t pstate_control;    // P-state control
    uint32_t pm1a_event_block; // PM1a Event Register Block
    uint32_t pm1b_event_block; // PM1b Event Register Block
    uint32_t pm1a_control_block; // PM1a Control Register Block
    uint32_t pm1b_control_block; // PM1b Control Register Block
    uint32_t pm2_control_block;  // PM2 Control Register Block
    uint32_t pm_timer_block;     // PM Timer Control Register Block
    uint32_t gpe0_block;         // GPE0 Register Block
    uint32_t gpe1_block;         // GPE1 Register Block
    uint8_t pm1_event_length;    // Length of PM1 Event Register Block
    uint8_t pm1_control_length;  // Length of PM1 Control Register Block
    uint8_t pm2_control_length;  // Length of PM2 Control Register Block
    uint8_t pm_timer_length;     // Length of PM Timer Register Block
    uint8_t gpe0_length;         // Length of GPE0 Register Block
    uint8_t gpe1_length;         // Length of GPE1 Register Block
    uint8_t gpe1_base;           // GPE1 base offset
    uint8_t cst_control;         // C-state control
    uint16_t worst_c2_latency;   // Worst case C2 latency
    uint16_t worst_c3_latency;   // Worst case C3 latency
    uint16_t flush_size;         // Cache flush size
    uint16_t flush_stride;       // Cache flush stride
    uint8_t duty_offset;         // Duty cycle offset
    uint8_t duty_width;          // Duty cycle width
    uint8_t day_alarm;           // RTC day alarm index
    uint8_t month_alarm;         // RTC month alarm index
    uint8_t century;             // RTC century index
    uint16_t boot_arch_flags;    // IA-PC Boot Architecture Flags
    uint8_t reserved2;           // Reserved
    uint32_t flags;              // Fixed feature flags
    generic_address_t reset_register;
    uint8_t reset_value;
    uint8_t reserved3[3];
    // ACPI 2.0+ fields would follow, but we'll keep it simple for now
} acpi_fadt_t;

// ACPI Power Management structures
typedef struct {
    bool acpi_enabled;
    bool sci_enabled;
    uint16_t pm1a_control_port;
    uint16_t pm1b_control_port;
    uint16_t pm1a_status_port;
    uint16_t pm1b_status_port;
    uint16_t pm2_control_port;
    uint16_t smi_command_port;
    uint8_t acpi_enable_value;
    uint8_t acpi_disable_value;
    uint8_t s5_sleep_type_a;
    uint8_t s5_sleep_type_b;
    generic_address_t reset_reg;
    uint8_t reset_value;
} acpi_pm_info_t;

// ACPI system information
typedef struct {
    acpi_rsdp_t* rsdp;
    acpi_rsdt_t* rsdt;
    acpi_xsdt_t* xsdt;
    acpi_fadt_t* fadt;
    acpi_pm_info_t pm_info;
    uint32_t table_count;
    void* tables[MAX_ACPI_TABLES];
    bool initialized;
    uint8_t acpi_version; // 1 for ACPI 1.0, 2 for ACPI 2.0+
} acpi_info_t;

// Global ACPI information
extern acpi_info_t acpi_info;

// Main ACPI functions
void acpi_init(void);
acpi_rsdp_t* acpi_find_rsdp(void);
bool acpi_validate_checksum(void* table, size_t length);
void* acpi_find_table(const char* signature);
void acpi_parse_tables(void);

// Power management functions
bool acpi_enable(void);
bool acpi_disable(void);
void acpi_power_off(void);
void acpi_reboot(void);
void acpi_suspend(void);

// Utility functions
void acpi_list_tables(void);
const char* acpi_get_table_name(const char* signature);
bool acpi_is_supported(void);
uint8_t acpi_get_version(void);

// Helper functions for implementation
acpi_rsdp_t* acpi_search_rsdp_in_range(void* start, size_t length);
void acpi_parse_rsdt(void);
void acpi_parse_xsdt(void);

#endif // ACPI_H



================================================================================
FILE: io.h
================================================================================

#ifndef IO_H
#define IO_H

#include <stdint.h>

// Lee un byte del puerto especificado
static inline uint8_t inb(uint16_t port) {
    uint8_t ret;
    __asm__ volatile ("inb %1, %0" : "=a"(ret) : "Nd"(port));
    return ret;
}

// EnvÃ­a un byte al puerto especificado
static inline void outb(uint16_t port, uint8_t value) {
    __asm__ volatile ("outb %0, %1" : : "a"(value), "Nd"(port));
}

// Lee una palabra (2 bytes) del puerto especificado
static inline uint16_t inw(uint16_t port) {
    uint16_t ret;
    __asm__ volatile ("inw %1, %0" : "=a"(ret) : "Nd"(port));
    return ret;
}

// EnvÃ­a una palabra (2 bytes) al puerto especificado
static inline void outw(uint16_t port, uint16_t value) {
    __asm__ volatile ("outw %0, %1" : : "a"(value), "Nd"(port));
}

// Lee un long (4 bytes) del puerto especificado
static inline uint32_t inl(uint16_t port) {
    uint32_t ret;
    __asm__ volatile ("inl %1, %0" : "=a"(ret) : "Nd"(port));
    return ret;
}

// EnvÃ­a un long (4 bytes) al puerto especificado
static inline void outl(uint16_t port, uint32_t value) {
    __asm__ volatile ("outl %0, %1" : : "a"(value), "Nd"(port));
}

// Lee 'count' palabras (16-bit) desde el puerto a la memoria
static inline void insw(uint16_t port, volatile void* addr, uint32_t count) {
    __asm__ volatile (
        "cld; rep insw"
        : "=D"(addr)
        : "d"(port), "c"(count), "0"(addr)
        : "memory"
    );
}

// Escribe 'count' palabras (16-bit) desde la memoria al puerto
static inline void outsw(uint16_t port, const volatile void* addr, uint32_t count) {
    __asm__ volatile (
        "cld; rep outsw"
        : "=S"(addr)
        : "d"(port), "c"(count), "0"(addr)
        : "memory"
    );
}

// Funciones para Memory-Mapped I/O (MMIO) - NUEVAS
static inline uint8_t readb(uint32_t addr) {
    return *(volatile uint8_t*)addr;
}

static inline void writeb(uint32_t addr, uint8_t value) {
    *(volatile uint8_t*)addr = value;
}

static inline uint16_t readw(uint32_t addr) {
    return *(volatile uint16_t*)addr;
}

static inline void writew(uint32_t addr, uint16_t value) {
    *(volatile uint16_t*)addr = value;
}

static inline uint32_t readl(uint32_t addr) {
    return *(volatile uint32_t*)addr;
}

static inline void writel(uint32_t addr, uint32_t value) {
    *(volatile uint32_t*)addr = value;
}

static inline void io_wait(void) {
    __asm__ volatile ("outb %%al, $0x80" : : "a"(0));
}

#endif // IO_H



================================================================================
FILE: partition_manager.h
================================================================================

#ifndef PARTITION_MANAGER_H
#define PARTITION_MANAGER_H

#include "disk.h"
#include "partition.h"
#include "terminal.h"
#include <stdbool.h>
#include <stdint.h>


#define MAX_DISKS 8
#define MAX_PARTITIONS_PER_DISK 16

typedef enum {
  PART_MGR_OK = 0,
  PART_MGR_ERR_INVALID_DISK,
  PART_MGR_ERR_NO_PARTITIONS,
  PART_MGR_ERR_INVALID_PARTITION,
  PART_MGR_ERR_READ_FAILED,
  PART_MGR_ERR_WRITE_FAILED,
  PART_MGR_ERR_OVERLAP,
  PART_MGR_ERR_NO_SPACE,
  PART_MGR_ERR_LBA_OUT_OF_RANGE
} part_mgr_err_t;

typedef struct {
  disk_t *disk;
  partition_table_t partition_table;
  bool initialized;
  uint32_t disk_id;
} disk_partitions_t;

uint64_t partition_calculate_next_start_lba(partition_table_t *pt);

// GestiÃ³n de particiones
part_mgr_err_t partition_manager_init(void);
part_mgr_err_t partition_manager_scan_disk(disk_t *disk, uint32_t disk_id);
part_mgr_err_t
partition_manager_create_partition(uint32_t disk_id, uint8_t part_num,
                                   uint8_t type, uint64_t start_lba,
                                   uint64_t sector_count, bool bootable);
part_mgr_err_t partition_manager_delete_partition(uint32_t disk_id,
                                                  uint8_t part_num);
part_mgr_err_t partition_manager_format_partition(uint32_t disk_id,
                                                  uint8_t part_num,
                                                  const char *fs_type);
part_mgr_err_t partition_manager_set_bootable(uint32_t disk_id,
                                              uint8_t part_num, bool bootable);

// InformaciÃ³n y listado
disk_partitions_t *partition_manager_get_disk(uint32_t disk_id);
partition_info_t *partition_manager_get_partition(uint32_t disk_id,
                                                  uint8_t part_num);
uint32_t partition_manager_get_disk_count(void);
void partition_manager_list_disks(void);
void partition_manager_list_partitions(uint32_t disk_id);

// Utilidades para VFS
part_mgr_err_t partition_manager_mount_partition(uint32_t disk_id,
                                                 uint8_t part_num,
                                                 const char *mount_point,
                                                 const char *fs_type);
part_mgr_err_t partition_manager_auto_mount_all(void);

// VerificaciÃ³n y reparaciÃ³n
bool partition_manager_verify_partition_table(uint32_t disk_id);
part_mgr_err_t partition_manager_repair_partition_table(uint32_t disk_id);

// Comandos de particiones
void part_list_command(Terminal *term, const char *args);
void part_space_command(Terminal *term, const char *args);
void part_create_command(Terminal *term, const char *args);
void part_delete_command(Terminal *term, const char *args);
void part_fix_order_command(Terminal *term, const char *args);
void part_format_command(Terminal *term, const char *args);
void part_mount_command(Terminal *term, const char *args);
void part_info_command(Terminal *term, const char *args);
void part_scan_command(Terminal *term, const char *args);
void part_help_command(Terminal *term, const char *args);

// Comando de formateo avanzado
void part_format_advanced_command(Terminal *term, const char *args);

#endif



================================================================================
FILE: syscalls.h
================================================================================

#ifndef SYSCALLS_H
#define SYSCALLS_H

#include "isr.h"
#include <stdint.h>

// NÃºmeros de syscall (POSIX-like)
#define SYSCALL_EXIT 0x00
#define SYSCALL_WRITE 0x01
#define SYSCALL_READ 0x02
#define SYSCALL_GETPID 0x03
#define SYSCALL_YIELD 0x04
#define SYSCALL_SLEEP 0x05
#define SYSCALL_GETTIME 0x06
#define SYSCALL_OPEN 0x07
#define SYSCALL_CLOSE 0x08
#define SYSCALL_GETCWD 0x09
#define SYSCALL_CHDIR 0x0A
#define SYSCALL_STAT 0x0B
#define SYSCALL_FORK 0x0C
#define SYSCALL_EXECVE 0x0D
#define SYSCALL_READKEY 0x0E       // Leer tecla del teclado
#define SYSCALL_KEY_AVAILABLE 0x0F // Verificar si hay teclas disponibles
#define SYSCALL_GETC 0x10          // Obtener caracter (similar a getchar)
#define SYSCALL_GETS 0x11          // Obtener string (similar a gets)
#define SYSCALL_KBHIT 0x12         // Verificar si hay tecla disponible
#define SYSCALL_KBFLUSH 0x13       // Limpiar buffer del teclado
#define SYSCALL_MKDIR 0x14         // Crear directorio
#define SYSCALL_RMDIR 0x15         // Eliminar directorio
#define SYSCALL_UNLINK 0x16        // Eliminar archivo
#define SYSCALL_SEEK 0x17          // Mover puntero de archivo
#define SYSCALL_TELL 0x18          // Obtener posiciÃ³n en archivo
#define SYSCALL_IOCTL 0x19         // Control de dispositivo
#define SYSCALL_GETPPID 0x1A       // Obtener PID del padre
#define SYSCALL_GETUID 0x1B        // Obtener UID
#define SYSCALL_GETGID 0x1C        // Obtener GID
#define SYSCALL_DUP 0x1D           // Duplicar descriptor de archivo
#define SYSCALL_DUP2 0x1E          // Duplicar descriptor con nÃºmero especÃ­fico
#define SYSCALL_PIPE 0x1F          // Crear pipe
#define SYSCALL_WAITPID 0x20       // Esperar proceso hijo
#define SYSCALL_BRK 0x21           // Control de heap
#define SYSCALL_SBRK 0x22          // Cambiar tamaÃ±o del heap
#define SYSCALL_MMAP 0x23          // Mapear memoria
#define SYSCALL_MUNMAP 0x24        // Desmapear memoria
#define SYSCALL_GETDENTS 0x25      // Leer directorio
#define SYSCALL_FSTAT 0x26         // EstadÃ­sticas de archivo abierto
#define SYSCALL_FSYNC 0x27         // Sincronizar archivo
#define SYSCALL_TRUNCATE 0x28      // Truncar archivo
#define SYSCALL_ACCESS 0x29        // Verificar acceso a archivo
#define SYSCALL_CHMOD 0x2A         // Cambiar permisos
#define SYSCALL_CHOWN 0x2B         // Cambiar propietario
#define SYSCALL_UMASK 0x2C         // Cambiar mÃ¡scara de permisos
#define SYSCALL_GETRUSAGE 0x2D     // Obtener uso de recursos
#define SYSCALL_TIMES 0x2E         // Obtener tiempos del proceso
#define SYSCALL_UNAME 0x2F         // Obtener informaciÃ³n del sistema
#define SYSCALL_SYSCONF 0x30       // Obtener configuraciÃ³n del sistema
#define SYSCALL_GETPGRP 0x31       // Obtener grupo de proceso
#define SYSCALL_SETPGID 0x32       // Establecer grupo de proceso
#define SYSCALL_SETSID 0x33        // Crear nueva sesiÃ³n
#define SYSCALL_GETSID 0x34        // Obtener ID de sesiÃ³n
#define SYSCALL_MOUNT 0x35         // Montar filesystem
#define SYSCALL_UMOUNT 0x36        // Desmontar filesystem
#define SYSCALL_LSEEK 0x37         // Mover puntero de archivo (alias)
#define SYSCALL_LINK 0x38          // Crear enlace fÃ­sico
#define SYSCALL_SYMLINK 0x39       // Crear enlace simbÃ³lico
#define SYSCALL_READLINK 0x3A      // Leer enlace simbÃ³lico
#define SYSCALL_RENAME 0x3B        // Renombrar archivo
#define SYSCALL_FCHDIR 0x3C        // Cambiar directorio por FD
#define SYSCALL_FCHMOD 0x3D        // Cambiar permisos de archivo abierto
#define SYSCALL_FCHOWN 0x3E        // Cambiar propietario de archivo abierto
#define SYSCALL_UTIME 0x3F         // Cambiar tiempos de acceso/modificaciÃ³n
#define SYSCALL_SYNC 0x40          // Sincronizar filesystem

// âœ… Definir cÃ³digos de error
#define EPERM 1
#define ENOENT 2
#define ESRCH 3
#define EIO 5
#define ENXIO 6
#define EBADF 9
#define ECHILD 10
#define EAGAIN 11
#define ENOMEM 12
#define EACCES 13
#define EFAULT 14
#define EBUSY 16
#define EEXIST 17
#define ENODEV 19
#define ENOTDIR 20
#define EISDIR 21
#define EINVAL 22
#define ENFILE 23
#define EMFILE 24
#define ENOTTY 25
#define ETXTBSY 26
#define EFBIG 27
#define ENOSPC 28
#define ESPIPE 29
#define EROFS 30
#define EMLINK 31
#define EPIPE 32
#define EDOM 33
#define ERANGE 34
#define EDEADLK 35
#define ENAMETOOLONG 36
#define ENOLCK 37
#define ENOSYS 38
#define ENOTEMPTY 39
#define ELOOP 40
#define EWOULDBLOCK EAGAIN
#define ENOMSG 42
#define EIDRM 43
#define ECHRNG 44
#define EL2NSYNC 45
#define EL3HLT 46
#define EL3RST 47
#define ELNRNG 48
#define EUNATCH 49
#define ENOCSI 50
#define EL2HLT 51
#define EBADE 52
#define EBADR 53
#define EXFULL 54
#define ENOANO 55
#define EBADRQC 56
#define EBADSLT 57
#define EDEADLOCK EDEADLK
#define EBFONT 59
#define ENOSTR 60
#define ENODATA 61
#define ETIME 62
#define ENOSR 63
#define ENONET 64
#define ENOPKG 65
#define EREMOTE 66
#define ENOLINK 67
#define EADV 68
#define ESRMNT 69
#define ECOMM 70
#define EPROTO 71
#define EMULTIHOP 72
#define EDOTDOT 73
#define EBADMSG 74
#define EOVERFLOW 75
#define ENOTUNIQ 76
#define EBADFD 77
#define EREMCHG 78
#define ELIBACC 79
#define ELIBBAD 80
#define ELIBSCN 81
#define ELIBMAX 82
#define ELIBEXEC 83
#define EILSEQ 84
#define ERESTART 85
#define ESTRPIPE 86
#define EUSERS 87
#define ENOTSOCK 88
#define EDESTADDRREQ 89
#define EMSGSIZE 90
#define EPROTOTYPE 91
#define ENOPROTOOPT 92
#define EPROTONOSUPPORT 93
#define ESOCKTNOSUPPORT 94
#define EOPNOTSUPP 95
#define EPFNOSUPPORT 96
#define EAFNOSUPPORT 97
#define EADDRINUSE 98
#define EADDRNOTAVAIL 99
#define ENETDOWN 100
#define ENETUNREACH 101
#define ENETRESET 102
#define ECONNABORTED 103
#define ECONNRESET 104
#define ENOBUFS 105
#define EISCONN 106
#define ENOTCONN 107
#define ESHUTDOWN 108
#define ETOOMANYREFS 109
#define ETIMEDOUT 110
#define ECONNREFUSED 111
#define EHOSTDOWN 112
#define EHOSTUNREACH 113
#define EALREADY 114
#define EINPROGRESS 115
#define ESTALE 116
#define EUCLEAN 117
#define ENOTNAM 118
#define ENAVAIL 119
#define EISNAM 120
#define EREMOTEIO 121
#define EDQUOT 122
#define ENOMEDIUM 123
#define EMEDIUMTYPE 124
#define ECANCELED 125
#define ENOKEY 126
#define EKEYEXPIRED 127
#define EKEYREVOKED 128
#define EKEYREJECTED 129
#define EOWNERDEAD 130
#define ENOTRECOVERABLE 131
#define ERFKILL 132
#define EHWPOISON 133

// Estructuras adicionales para syscalls
typedef struct {
  uint32_t st_dev;     // Device ID
  uint32_t st_ino;     // Inode number
  uint16_t st_mode;    // File type and mode
  uint16_t st_nlink;   // Number of hard links
  uint16_t st_uid;     // User ID of owner
  uint16_t st_gid;     // Group ID of owner
  uint32_t st_rdev;    // Device ID (if special file)
  uint32_t st_size;    // Total size, in bytes
  uint32_t st_blksize; // Block size for filesystem I/O
  uint32_t st_blocks;  // Number of 512-byte blocks allocated
  uint32_t st_atime;   // Time of last access
  uint32_t st_mtime;   // Time of last modification
  uint32_t st_ctime;   // Time of last status change
} vfs_stat_t;

typedef struct {
  char sysname[65];    // Operating system name
  char nodename[65];   // Name within network
  char release[65];    // Operating system release
  char version[65];    // Operating system version
  char machine[65];    // Hardware identifier
  char domainname[65]; // Network domain
} uname_t;

// Prototipos bÃ¡sicos
void syscall_init(void);
void syscall_handler(struct regs *r);

// Funciones de utilidad para syscalls
bool validate_user_pointer(uint32_t ptr, uint32_t size);
int copy_from_user(void *kernel_dst, uint32_t user_src, size_t size);
int copy_to_user(uint32_t user_dst, void *kernel_src, size_t size);
int copy_string_from_user(char *kernel_dst, uint32_t user_src, size_t max_len);
int copy_string_to_user(uint32_t user_dst, const char *kernel_src,
                        size_t max_len);

#endif // SYSCALLS_H



================================================================================
FILE: apic.h
================================================================================

#ifndef APIC_H
#define APIC_H

#include <stdbool.h>
#include <stdint.h>

// ========================================================================
// ESTRUCTURAS MADT (Multiple APIC Description Table)
// ========================================================================

// Entry types en MADT
#define MADT_TYPE_LOCAL_APIC 0
#define MADT_TYPE_IO_APIC 1
#define MADT_TYPE_INTERRUPT_OVERRIDE 2
#define MADT_TYPE_NMI 4
#define MADT_TYPE_LOCAL_APIC_OVERRIDE 5

// Flags de MADT
#define MADT_FLAG_PCAT_COMPAT (1 << 0) // Sistema tiene PIC legacy

typedef struct __attribute__((packed)) {
  uint8_t type;
  uint8_t length;
} madt_entry_header_t;

typedef struct __attribute__((packed)) {
  madt_entry_header_t header;
  uint8_t acpi_processor_id;
  uint8_t apic_id;
  uint32_t flags; // Bit 0: Processor Enabled, Bit 1: Online Capable
} madt_local_apic_t;

typedef struct __attribute__((packed)) {
  madt_entry_header_t header;
  uint8_t io_apic_id;
  uint8_t reserved;
  uint32_t io_apic_address;
  uint32_t global_system_interrupt_base;
} madt_io_apic_t;

typedef struct __attribute__((packed)) {
  madt_entry_header_t header;
  uint8_t bus_source;               // 0 = ISA
  uint8_t irq_source;               // IRQ en el bus source
  uint32_t global_system_interrupt; // GSI que debe usar
  uint16_t flags;                   // Polarity y trigger mode
} madt_interrupt_override_t;

// ========================================================================
// LOCAL APIC
// ========================================================================

// Registros del Local APIC (offsets desde base address)
#define LAPIC_ID 0x020          // Local APIC ID
#define LAPIC_VERSION 0x030     // Local APIC Version
#define LAPIC_TPR 0x080         // Task Priority Register
#define LAPIC_APR 0x090         // Arbitration Priority Register
#define LAPIC_PPR 0x0A0         // Processor Priority Register
#define LAPIC_EOI 0x0B0         // End Of Interrupt
#define LAPIC_RRD 0x0C0         // Remote Read Register
#define LAPIC_LDR 0x0D0         // Logical Destination Register
#define LAPIC_DFR 0x0E0         // Destination Format Register
#define LAPIC_SVR 0x0F0         // Spurious Interrupt Vector Register
#define LAPIC_ISR 0x100         // In-Service Register (0x100-0x170)
#define LAPIC_TMR 0x180         // Trigger Mode Register (0x180-0x1F0)
#define LAPIC_IRR 0x200         // Interrupt Request Register (0x200-0x270)
#define LAPIC_ESR 0x280         // Error Status Register
#define LAPIC_CMCI 0x2F0        // LVT Corrected Machine Check Interrupt
#define LAPIC_ICR_LOW 0x300     // Interrupt Command Register (bits 0-31)
#define LAPIC_ICR_HIGH 0x310    // Interrupt Command Register (bits 32-63)
#define LAPIC_LVT_TIMER 0x320   // LVT Timer Register
#define LAPIC_LVT_THERMAL 0x330 // LVT Thermal Sensor Register
#define LAPIC_LVT_PMC 0x340     // LVT Performance Monitoring Counter
#define LAPIC_LVT_LINT0 0x350   // LVT LINT0 Register
#define LAPIC_LVT_LINT1 0x360   // LVT LINT1 Register
#define LAPIC_LVT_ERROR 0x370   // LVT Error Register
#define LAPIC_TIMER_ICR 0x380   // Timer Initial Count Register
#define LAPIC_TIMER_CCR 0x390   // Timer Current Count Register
#define LAPIC_TIMER_DCR 0x3E0   // Timer Divide Configuration Register

// Flags para Spurious Interrupt Vector Register
#define LAPIC_SVR_ENABLE (1 << 8)
#define LAPIC_SPURIOUS_VECTOR 0xFF

// Flags para LVT
#define LAPIC_LVT_MASKED (1 << 16)
#define LAPIC_LVT_TIMER_PERIODIC (1 << 17)
#define LAPIC_LVT_TIMER_TSC_DEADLINE (1 << 18)

// Timer divide values
#define LAPIC_TIMER_DIV_1 0x0B
#define LAPIC_TIMER_DIV_2 0x00
#define LAPIC_TIMER_DIV_4 0x01
#define LAPIC_TIMER_DIV_8 0x02
#define LAPIC_TIMER_DIV_16 0x03
#define LAPIC_TIMER_DIV_32 0x08
#define LAPIC_TIMER_DIV_64 0x09
#define LAPIC_TIMER_DIV_128 0x0A

// Delivery Mode para ICR
#define LAPIC_DELIVERY_FIXED 0x0
#define LAPIC_DELIVERY_LOWEST 0x1
#define LAPIC_DELIVERY_SMI 0x2
#define LAPIC_DELIVERY_NMI 0x4
#define LAPIC_DELIVERY_INIT 0x5
#define LAPIC_DELIVERY_STARTUP 0x6

// ========================================================================
// I/O APIC
// ========================================================================

// Registros del I/O APIC
#define IOAPIC_REG_ID 0x00
#define IOAPIC_REG_VERSION 0x01
#define IOAPIC_REG_ARB 0x02
#define IOAPIC_REG_REDTBL_BASE 0x10

// Offsets dentro de la estructura MMIO del I/O APIC
#define IOAPIC_REGSEL 0x00
#define IOAPIC_REGWIN 0x10

// Flags para entradas de redirecciÃ³n del I/O APIC
#define IOAPIC_DELIVERY_FIXED 0x000
#define IOAPIC_DELIVERY_LOWEST 0x100
#define IOAPIC_DELIVERY_SMI 0x200
#define IOAPIC_DELIVERY_NMI 0x400
#define IOAPIC_DELIVERY_INIT 0x500
#define IOAPIC_DELIVERY_EXTINT 0x700

#define IOAPIC_DEST_PHYSICAL 0x000
#define IOAPIC_DEST_LOGICAL 0x800

#define IOAPIC_POLARITY_HIGH 0x0000
#define IOAPIC_POLARITY_LOW 0x2000

#define IOAPIC_TRIGGER_EDGE 0x0000
#define IOAPIC_TRIGGER_LEVEL 0x8000

#define IOAPIC_MASKED 0x10000

// ========================================================================
// MSR (Model Specific Registers) para APIC
// ========================================================================

#define IA32_APIC_BASE_MSR 0x1B
#define IA32_APIC_BASE_BSP (1 << 8)     // Bootstrap Processor
#define IA32_APIC_BASE_ENABLE (1 << 11) // APIC Enable
#define IA32_APIC_BASE_X2APIC (1 << 10) // x2APIC mode

// ========================================================================
// ESTRUCTURAS DE DATOS
// ========================================================================

typedef struct {
  uint8_t io_apic_id;
  uint32_t base_address;
  uint32_t virtual_address;
  uint32_t gsi_base;
  uint8_t max_redirect_entries;
} io_apic_info_t;

typedef struct {
  uint8_t processor_id;
  uint8_t apic_id;
  bool enabled;
  bool online_capable;
} local_apic_info_t;

typedef struct {
  uint8_t irq_source;
  uint32_t gsi;
  uint16_t flags;
  bool active_low;
  bool level_triggered;
} interrupt_override_t;

typedef struct {
  // Local APIC
  uint32_t lapic_base_phys;
  uint32_t lapic_base_virt;
  bool lapic_enabled;
  uint8_t lapic_id;
  uint32_t lapic_version;

  // I/O APIC(s)
  io_apic_info_t io_apics[8];
  uint8_t io_apic_count;

  // Local APICs (para multi-core en el futuro)
  local_apic_info_t local_apics[256];
  uint8_t local_apic_count;

  // Interrupt overrides
  interrupt_override_t overrides[24];
  uint8_t override_count;

  // Estado
  bool initialized;
  bool using_apic; // true si usamos APIC, false si PIC
  bool pic_disabled;

  // Timer
  uint32_t timer_frequency;
  uint32_t timer_ticks_per_ms;
} apic_info_t;

// Variable global
extern apic_info_t apic_info;

// ========================================================================
// FUNCIONES PRINCIPALES
// ========================================================================

// InicializaciÃ³n
bool apic_init(void);
bool apic_check_support(void);
void apic_enable(void);
void apic_disable(void);
bool apic_verify_state(void);

// Local APIC
void lapic_write(uint32_t reg, uint32_t value);
uint32_t lapic_read(uint32_t reg);
void lapic_eoi(void);
uint8_t lapic_get_id(void);

// Timer del Local APIC
void lapic_timer_init(uint32_t frequency_hz);
void lapic_timer_oneshot(uint32_t initial_count);
void lapic_timer_periodic(uint32_t initial_count);
void lapic_timer_stop(void);
uint32_t lapic_timer_calibrate(void);

// I/O APIC
void ioapic_write(uint8_t io_apic_index, uint8_t reg, uint32_t value);
uint32_t ioapic_read(uint8_t io_apic_index, uint8_t reg);
void ioapic_set_irq(uint8_t irq, uint8_t vector, bool masked);
void ioapic_mask_irq(uint8_t irq);
void ioapic_unmask_irq(uint8_t irq);

// Mapeo de IRQ a GSI (Global System Interrupt)
uint32_t apic_irq_to_gsi(uint8_t irq);
interrupt_override_t *apic_get_override(uint8_t irq);
void irq_setup_apic(void);

// Utilidades
void apic_print_info(void);
bool apic_is_enabled(void);
void apic_disable_pic(void);

// MSR helpers (inline)
static inline void wrmsr(uint32_t msr, uint64_t value) {
  uint32_t low = value & 0xFFFFFFFF;
  uint32_t high = value >> 32;
  __asm__ volatile("wrmsr" : : "c"(msr), "a"(low), "d"(high));
}

static inline uint64_t rdmsr(uint32_t msr) {
  uint32_t low, high;
  __asm__ volatile("rdmsr" : "=a"(low), "=d"(high) : "c"(msr));
  return ((uint64_t)high << 32) | low;
}

#endif // APIC



================================================================================
FILE: math_utils.h
================================================================================

// math_utils.h
#ifndef MATH_UTILS_H
#define MATH_UTILS_H

static inline int min(int a, int b) {
    return a < b ? a : b;
}

static inline int max(int a, int b) {
    return a > b ? a : b;
}

static inline int abs(int x) {
    return (x < 0) ? -x : x;
}


// AÃ±ade estas declaraciones
float sqrt(float x);
float cos(float x);
float sin(float x);

#endif



================================================================================
FILE: stdint.h
================================================================================

#ifndef _STDINT_H
#define _STDINT_H

#include <stddef.h>   // para size_t

// Tipos enteros fijos
typedef signed char        int8_t;
typedef unsigned char      uint8_t;
typedef short              int16_t;
typedef unsigned short     uint16_t;
typedef int                int32_t;
typedef unsigned int       uint32_t;
typedef long long          int64_t;
typedef unsigned long long uint64_t;

// Para sistemas de 32 bits (ajusta si es 64 bits)
typedef int32_t  intptr_t;
typedef uint32_t uintptr_t;

// ssize_t = signed size_t
typedef intptr_t ssize_t;

#endif




================================================================================
FILE: usb_ehci.h
================================================================================

#ifndef USB_EHCI_H
#define USB_EHCI_H

#include "usb_core.h"
#include "dma.h"

// EHCI Capability Registers (offsets from base)
#define EHCI_CAP_CAPLENGTH  0x00
#define EHCI_CAP_HCIVERSION 0x02
#define EHCI_CAP_HCSPARAMS  0x04
#define EHCI_CAP_HCCPARAMS  0x08

// EHCI Operational Registers (offsets from CAPLENGTH)
#define EHCI_OP_USBCMD      0x00
#define EHCI_OP_USBSTS      0x04
#define EHCI_OP_USBINTR     0x08
#define EHCI_OP_FRINDEX     0x0C
#define EHCI_OP_CTRLDSSEGMENT 0x10
#define EHCI_OP_PERIODICLISTBASE 0x14
#define EHCI_OP_ASYNCLISTADDR 0x18
#define EHCI_OP_CONFIGFLAG  0x40
#define EHCI_OP_PORTSC_BASE 0x44

// USBCMD Register Bits
#define EHCI_CMD_RS         (1 << 0)   // Run/Stop
#define EHCI_CMD_HCRESET    (1 << 1)   // Host Controller Reset
#define EHCI_CMD_FLS_1024   (0 << 2)   // Frame List Size 1024
#define EHCI_CMD_PSE        (1 << 4)   // Periodic Schedule Enable
#define EHCI_CMD_ASE        (1 << 5)   // Async Schedule Enable
#define EHCI_CMD_IAAD       (1 << 6)   // Interrupt on Async Advance Doorbell
#define EHCI_CMD_LHCRESET   (1 << 7)   // Light Host Controller Reset

// USBSTS Register Bits
#define EHCI_STS_USBINT     (1 << 0)   // USB Interrupt
#define EHCI_STS_USBERRINT  (1 << 1)   // USB Error Interrupt
#define EHCI_STS_PCD        (1 << 2)   // Port Change Detect
#define EHCI_STS_FLR        (1 << 3)   // Frame List Rollover
#define EHCI_STS_HSE        (1 << 4)   // Host System Error
#define EHCI_STS_IAA        (1 << 5)   // Interrupt on Async Advance
#define EHCI_STS_HCHALTED   (1 << 12)  // HC Halted
#define EHCI_STS_RECLAMATION (1 << 13) // Reclamation
#define EHCI_STS_PSS        (1 << 14)  // Periodic Schedule Status
#define EHCI_STS_ASS        (1 << 15)  // Async Schedule Status

// Port Status and Control Register Bits
#define EHCI_PORT_CCS       (1 << 0)   // Current Connect Status
#define EHCI_PORT_CSC       (1 << 1)   // Connect Status Change
#define EHCI_PORT_PE        (1 << 2)   // Port Enabled
#define EHCI_PORT_PEC       (1 << 3)   // Port Enable Change
#define EHCI_PORT_OCA       (1 << 4)   // Over-current Active
#define EHCI_PORT_OCC       (1 << 5)   // Over-current Change
#define EHCI_PORT_FPR       (1 << 6)   // Force Port Resume
#define EHCI_PORT_SUSPEND   (1 << 7)   // Suspend
#define EHCI_PORT_RESET     (1 << 8)   // Port Reset
#define EHCI_PORT_LS_MASK   (3 << 10)  // Line Status
#define EHCI_PORT_PP        (1 << 12)  // Port Power
#define EHCI_PORT_OWNER     (1 << 13)  // Port Owner (companion controller)
#define EHCI_PORT_IC_MASK   (3 << 14)  // Port Indicator Control

// Queue Head (QH) Link Pointer Bits
#define EHCI_QH_TYPE_ITD    0x00
#define EHCI_QH_TYPE_QH     0x02
#define EHCI_QH_TYPE_SITD   0x04
#define EHCI_QH_TYPE_FSTN   0x06
#define EHCI_QH_TERMINATE   0x01

// Queue Transfer Descriptor (qTD) Token Bits
#define EHCI_QTD_STATUS_ACTIVE      (1 << 7)
#define EHCI_QTD_STATUS_HALTED      (1 << 6)
#define EHCI_QTD_STATUS_DBERR       (1 << 5)
#define EHCI_QTD_STATUS_BABBLE      (1 << 4)
#define EHCI_QTD_STATUS_XACTERR     (1 << 3)
#define EHCI_QTD_STATUS_MISSED_uF   (1 << 2)
#define EHCI_QTD_STATUS_SPLIT_STATE (1 << 1)
#define EHCI_QTD_STATUS_PING_STATE  (1 << 0)

#define EHCI_QTD_PID_OUT    0x00
#define EHCI_QTD_PID_IN     0x01
#define EHCI_QTD_PID_SETUP  0x02

#define EHCI_QTD_IOC        (1 << 15)  // Interrupt on Complete
#define EHCI_QTD_CERR_MASK  (3 << 10)  // Error Counter

// Frame List Size
#define EHCI_FRAMELIST_SIZE 1024

// Maximum QH and qTD pools
#define EHCI_MAX_QH         32
#define EHCI_MAX_QTD        128

// Queue Transfer Descriptor (qTD)
typedef struct ehci_qtd {
    uint32_t next_qtd_ptr;
    uint32_t alt_next_qtd_ptr;
    uint32_t token;
    uint32_t buffer_ptr[5];
    
    // Software fields (not accessed by hardware)
    uint32_t reserved[7];
} __attribute__((packed, aligned(32))) ehci_qtd_t;

// Queue Head (QH)
typedef struct ehci_qh {
    uint32_t qh_link_ptr;
    uint32_t ep_characteristics;
    uint32_t ep_capabilities;
    uint32_t current_qtd_ptr;
    
    // Overlay area (matches qTD structure)
    uint32_t next_qtd_ptr;
    uint32_t alt_next_qtd_ptr;
    uint32_t token;
    uint32_t buffer_ptr[5];
    
    // Software fields
    uint32_t reserved[4];
} __attribute__((packed, aligned(32))) ehci_qh_t;

// EHCI Controller Data
typedef struct {
    uint8_t* cap_regs;          // Capability registers (virtual)
    uint8_t* op_regs;           // Operational registers (virtual)
    uint32_t cap_regs_phys;     // Capability registers (physical)
    uint32_t op_regs_phys;      // Operational registers (physical)
    
    uint8_t num_ports;
    uint8_t cap_length;
    
    // Frame list (periodic schedule)
    dma_buffer_t* framelist_buffer;
    uint32_t* framelist;
    
    // Async schedule
    dma_buffer_t* async_qh_buffer;
    ehci_qh_t* async_qh;
    
    // QH and qTD pools
    dma_buffer_t* qh_pool_buffer;
    ehci_qh_t* qh_pool;
    bool qh_used[EHCI_MAX_QH];
    
    dma_buffer_t* qtd_pool_buffer;
    ehci_qtd_t* qtd_pool;
    bool qtd_used[EHCI_MAX_QTD];
} ehci_data_t;

// Function prototypes
bool ehci_init(usb_controller_t* controller);
void ehci_cleanup(usb_controller_t* controller);
bool ehci_detect_ports(usb_controller_t* controller);
bool ehci_reset_port(usb_controller_t* controller, uint8_t port);

// Transfer functions
bool ehci_control_transfer(usb_device_t* device, usb_setup_packet_t* setup,
                           void* data, uint16_t length);
bool ehci_bulk_transfer(usb_device_t* device, uint8_t endpoint,
                        void* data, uint32_t length, bool is_in);

// Internal functions
ehci_qh_t* ehci_alloc_qh(ehci_data_t* ehci);
void ehci_free_qh(ehci_data_t* ehci, ehci_qh_t* qh);
ehci_qtd_t* ehci_alloc_qtd(ehci_data_t* ehci);
void ehci_free_qtd(ehci_data_t* ehci, ehci_qtd_t* qtd);
bool ehci_wait_for_qtd(ehci_qtd_t* qtd, uint32_t timeout_ms);

#endif // USB_EHCI_H



================================================================================
FILE: gdt.h
================================================================================

#ifndef GDT_H
#define GDT_H

#include <stddef.h>
#include <stdint.h>

#define GDT_ENTRIES 6

// Definiciones de estructuras (mover aquÃ­ desde gdt.c)
struct gdt_entry {
  uint16_t limit_low;
  uint16_t base_low;
  uint8_t base_middle;
  uint8_t access;
  uint8_t granularity;
  uint8_t base_high;
} __attribute__((packed));

struct gdt_ptr {
  uint16_t limit;
  uint32_t base;
} __attribute__((packed));

struct tss_entry {
  uint32_t prev_tss;
  uint32_t esp0;
  uint32_t ss0;
  uint32_t esp1;
  uint32_t ss1;
  uint32_t esp2;
  uint32_t ss2;
  uint32_t cr3;
  uint32_t eip;
  uint32_t eflags;
  uint32_t eax, ecx, edx, ebx;
  uint32_t esp, ebp, esi, edi;
  uint32_t es, cs, ss, ds, fs, gs;
  uint32_t ldt;
  uint16_t trap;
  uint16_t iomap_base;
} __attribute__((packed));

// Declaraciones externas
extern struct gdt_entry gdt[GDT_ENTRIES];
extern struct gdt_ptr gp;
extern struct tss_entry tss;

void gdt_init(void);

#endif



================================================================================
FILE: mouse.h
================================================================================

#ifndef MOUSE_H
#define MOUSE_H

#include <stdint.h>
#include <stdbool.h>

// Comandos del mouse PS/2
#define MOUSE_CMD_RESET             0xFF
#define MOUSE_CMD_RESEND            0xFE
#define MOUSE_CMD_SET_DEFAULTS      0xF6
#define MOUSE_CMD_DISABLE_DATA_REP  0xF5
#define MOUSE_CMD_ENABLE_DATA_REP   0xF4
#define MOUSE_CMD_SET_SAMPLE_RATE   0xF3
#define MOUSE_CMD_GET_DEVICE_ID     0xF2
#define MOUSE_CMD_SET_REMOTE_MODE   0xF0
#define MOUSE_CMD_SET_WRAP_MODE     0xEE
#define MOUSE_CMD_RESET_WRAP_MODE   0xEC
#define MOUSE_CMD_READ_DATA         0xEB
#define MOUSE_CMD_SET_STREAM_MODE   0xEA
#define MOUSE_CMD_STATUS_REQUEST    0xE9
#define MOUSE_CMD_SET_RESOLUTION    0xE8
#define MOUSE_CMD_SET_SCALING_2_1   0xE7
#define MOUSE_CMD_SET_SCALING_1_1   0xE6

// Estados del mouse
#define MOUSE_LEFT_BUTTON   0x01
#define MOUSE_RIGHT_BUTTON  0x02
#define MOUSE_MIDDLE_BUTTON 0x04
#define MOUSE_X_SIGN        0x10
#define MOUSE_Y_SIGN        0x20
#define MOUSE_X_OVERFLOW    0x40
#define MOUSE_Y_OVERFLOW    0x80

// Puerto PS/2
#define PS2_DATA_PORT       0x60
#define PS2_STATUS_PORT     0x64
#define PS2_COMMAND_PORT    0x64

// Estados del puerto PS/2
#define PS2_STATUS_OUTPUT_FULL  0x01
#define PS2_STATUS_INPUT_FULL   0x02
#define PS2_STATUS_SYSTEM_FLAG  0x04
#define PS2_STATUS_COMMAND_DATA 0x08
#define PS2_STATUS_TIMEOUT_ERR  0x40
#define PS2_STATUS_PARITY_ERR   0x80

// ConfiguraciÃ³n del mouse
#define MOUSE_SAMPLE_RATE   100     // 100 muestras/segundo
#define MOUSE_RESOLUTION    3       // 8 counts/mm
#define MOUSE_SCALING       1       // 1:1 scaling

// Estructura del estado del mouse
typedef struct {
    int32_t x, y;           // PosiciÃ³n actual
    int32_t last_x, last_y; // PosiciÃ³n anterior
    uint8_t buttons;        // Estado de botones (bit 0: izquierdo, bit 1: derecho, bit 2: medio)
    uint8_t last_buttons;   // Estado anterior de botones
    bool enabled;           // Mouse habilitado
    bool packet_ready;      // Paquete listo para procesar
    uint8_t packet[4];      // Buffer del paquete
    uint8_t packet_index;   // Ãndice del paquete actual
    int32_t min_x, max_x;   // LÃ­mites de pantalla
    int32_t min_y, max_y;
    uint32_t screen_width;
    uint32_t screen_height;
    bool cursor_visible;    // Visibilidad del cursor
    uint32_t saved_background[16 * 8]; // Buffer para guardar fondo bajo cursor (8x16)
} mouse_state_t;

// Funciones pÃºblicas
void mouse_init(uint32_t screen_width, uint32_t screen_height);
void mouse_handle_irq(void);
void mouse_update_bounds(uint32_t new_width, uint32_t new_height);
void mouse_set_position(int32_t x, int32_t y);
void mouse_get_position(int32_t* x, int32_t* y);
uint8_t mouse_get_buttons(void);
bool mouse_is_moved(void);
bool mouse_is_clicked(uint8_t button);
bool mouse_is_pressed(uint8_t button);
bool mouse_is_released(uint8_t button);
void mouse_set_cursor_visible(bool visible);
bool mouse_get_cursor_visible(void);
void mouse_draw_cursor(void);
void mouse_erase_cursor(void);
void mouse_process_packet(void);

#endif // MOUSE_H



================================================================================
FILE: usb_commands.h
================================================================================

#ifndef USB_COMMANDS_H
#define USB_COMMANDS_H

// Handler principal para comandos USB
void cmd_usb(const char* args);

// Subcomandos individuales
void cmd_usb_list(void);
void cmd_usb_storage(void);
void cmd_usb_scan(void);
void cmd_usb_info(const char* device_str);

#endif // USB_COMMANDS_H



================================================================================
FILE: usb_ohci.h
================================================================================




================================================================================
FILE: memory.h
================================================================================

// memory.h - REVISADO CON VMM

#ifndef MEMORY_H
#define MEMORY_H

#include "mmu.h"
#include "multiboot2.h"
#include "terminal.h"
#include <stddef.h>
#include <stdint.h>

// ==================== CONSTANTES ====================
#define MAX_MEMORY_REGIONS 32
#define ALIGN8(x) (((x) + 7) & ~7)
#define ALIGN4K(x) (((x) + 0xFFF) & ~0xFFF)
#define MIN_BLOCK_SIZE (sizeof(heap_block_t) + 8)

// Magics para protecciÃ³n del heap
#define HEAP_MAGIC_OCCUPIED 0x48454150 // 'HEAP'
#define HEAP_MAGIC_FREE 0x46454150     // 'FEAP'

// Umbrales para desfragmentaciÃ³n
#define FRAGMENTATION_THRESHOLD 40.0f
#define MIN_DEFRAG_INTERVAL_MS 10000
#define FORCE_DEFRAG_INTERVAL_MS 60000

// ==================== VMM (Virtual Memory Manager) ====================

// RegiÃ³n de memoria virtual
typedef struct vmm_region {
  uint32_t virtual_start;
  uint32_t virtual_end;
  uint32_t physical_start; // 0 si no estÃ¡ respaldada por memoria fÃ­sica
  uint32_t flags;
  struct vmm_region *next;
  struct vmm_region *prev;
} vmm_region_t;

// Espacio de direcciones (para procesos)
typedef struct address_space {
  uint32_t page_directory; // DirecciÃ³n fÃ­sica del PD
  vmm_region_t *regions;   // Lista de regiones
  uint32_t heap_start;     // Inicio del heap
  uint32_t heap_current;   // Current break (como brk())
  uint32_t stack_start;    // Inicio del stack
  uint32_t stack_size;     // TamaÃ±o del stack
} address_space_t;

// ==================== HEAP ====================

typedef struct heap_block {
  uint32_t magic;
  size_t size;
  uint8_t free;
  struct heap_block *next;
} heap_block_t;

typedef struct {
  size_t used;
  size_t free;
  float fragmentation;
  size_t largest_free_block;
  uint32_t free_blocks_count;
} heap_info_t;

// ==================== TESTING ====================

typedef struct {
  uint32_t total_tests;
  uint32_t passed_tests;
  uint32_t failed_tests;
  char last_error[256];
} heap_test_results_t;

// ==================== DEFRAGMENTATION ====================

typedef struct {
  uint32_t total_defrags;
  uint32_t successful_merges;
  uint32_t last_defrag_time;
  uint32_t largest_block_before;
  uint32_t largest_block_after;
} defrag_stats_t;

// ==================== VARIABLES GLOBALES ====================

// VMM - DECLARACIÃ“N (la definiciÃ³n estÃ¡ en vmm.c)
extern address_space_t kernel_address_space;

// Heap
extern void *kernel_heap_start;
extern void *kernel_heap_end;
extern heap_block_t *free_list;
extern defrag_stats_t defrag_stats;

// ==================== PROTOTIPOS VMM ====================

void vmm_init(void);
address_space_t *vmm_create_address_space(void);
void vmm_destroy_address_space(address_space_t *as);
bool vmm_map_region(address_space_t *as, uint32_t virt_start, uint32_t size,
                    uint32_t flags);
bool vmm_unmap_region(address_space_t *as, uint32_t virt_start, uint32_t size);
bool vmm_allocate_stack(address_space_t *as, uint32_t size);
bool vmm_allocate_heap(address_space_t *as, uint32_t initial_size);
void *vmm_brk(address_space_t *as, void *addr);
void vmm_switch_address_space(address_space_t *as);
void vmm_debug_info(address_space_t *as, Terminal *term);

// ==================== PROTOTIPOS HEAP ====================

void heap_init(void *heap_memory, size_t heap_size);
void *kernel_malloc(size_t size);
int kernel_free(void *ptr);
void *kernel_realloc(void *ptr, size_t new_size);
void heap_defragment(void);
heap_info_t heap_stats(void);
heap_info_t heap_stats_fast(void);
size_t heap_available(void);
void heap_debug(Terminal *term);

// ==================== TESTING ====================

heap_test_results_t heap_run_exhaustive_tests(void);
void heap_print_test_results(const heap_test_results_t *results,
                             Terminal *term);

// ==================== DEFRAGMENTATION ====================

void memory_defrag_task(void *arg);
void defrag_print_stats(void);
void cmd_defrag_stats(void);
void cmd_force_defrag(void);

#endif



================================================================================
FILE: stddef.h
================================================================================

#ifndef _STDDEF_H
#define _STDDEF_H

typedef unsigned int size_t;
typedef int ptrdiff_t;

#define NULL ((void*)0)

#endif



================================================================================
FILE: isr.h
================================================================================

#ifndef ISR_H
#define ISR_H

#include <stddef.h>
#include <stdint.h>
#include "terminal.h"

// Estructura para guardar el estado del sistema
typedef struct {
    uint32_t last_exception;
    uint32_t exception_count;
    uint32_t task_count;
    uint8_t critical_error;
} SystemState;

struct regs {
    // Orden inverso a los pushs, desde el Ãºltimo al primero
    uint32_t gs, fs, es, ds;                        // pushed manually
    uint32_t edi, esi, ebp, esp_fake, ebx, edx, ecx, eax; // pusha
    uint32_t int_no, err_code;                     // manual push or CPU
    uint32_t eip, cs, eflags;                      // pushed by CPU
};

// Funciones pÃºblicas
void isr_handler(struct regs* r);
void print_registers(Terminal* term, struct regs* r);
void print_backtrace(uint32_t ebp);
void print_system_state(Terminal* term);
void print_task_info(Terminal* term);
void panic_screen(const char* exception_msg, struct regs* r);

// Variables globales
extern const char* exception_messages[];
extern SystemState system_state;
extern uint32_t last_fault_address;
extern uint32_t last_error_code;

// CORRECTA declaraciÃ³n como array de direcciones, no punteros a funciones
extern uintptr_t isr_stub_table[];

#endif



================================================================================
FILE: irq.h
================================================================================

#ifndef IRQ_H
#define IRQ_H

#include "isr.h"
#include <stddef.h>
#include <stdint.h>

// Definiciones para los IRQs
#define IRQ0  32
#define IRQ1  33
#define IRQ2  34
#define IRQ3  35
#define IRQ4  36
#define IRQ5  37
#define IRQ6  38
#define IRQ7  39
#define IRQ8  40
#define IRQ9  41
#define IRQ10 42
#define IRQ11 43
#define IRQ12 44
#define IRQ13 45
#define IRQ14 46
#define IRQ15 47

// Tabla de punteros a los stubs de IRQ
extern uintptr_t irq_stub_table[];
extern volatile uint32_t ticks;
extern volatile uint32_t ticks_since_boot;
// Tipo para manejadores de IRQ
typedef void (*irq_handler_t)(struct regs*);

// Funciones pÃºblicas
void timer_irq_handler(void);             // <-- Debe estar visible
void irq_common_handler(struct regs* r);
void pic_send_eoi(uint8_t irq);
void pit_init(uint32_t frequency);
void kernel_delay(uint32_t milliseconds);
void irq_setup_apic(void);

#endif



================================================================================
FILE: dma.h
================================================================================

#ifndef DMA_H
#define DMA_H

#include <stdint.h>
#include <stdbool.h>

// DMA Channel registers (ISA DMA)
#define DMA_CHANNEL_0_ADDRESS    0x00
#define DMA_CHANNEL_0_COUNT      0x01
#define DMA_CHANNEL_1_ADDRESS    0x02
#define DMA_CHANNEL_1_COUNT      0x03
#define DMA_CHANNEL_2_ADDRESS    0x04
#define DMA_CHANNEL_2_COUNT      0x05
#define DMA_CHANNEL_3_ADDRESS    0x06
#define DMA_CHANNEL_3_COUNT      0x07
#define DMA_CHANNEL_4_ADDRESS    0xC0
#define DMA_CHANNEL_4_COUNT      0xC2
#define DMA_CHANNEL_5_ADDRESS    0xC4
#define DMA_CHANNEL_5_COUNT      0xC6
#define DMA_CHANNEL_6_ADDRESS    0xC8
#define DMA_CHANNEL_6_COUNT      0xCA
#define DMA_CHANNEL_7_ADDRESS    0xCC
#define DMA_CHANNEL_7_COUNT      0xCE

// DMA Command registers
#define DMA_COMMAND_REG_0        0x08
#define DMA_COMMAND_REG_1        0xD0
#define DMA_STATUS_REG_0         0x08
#define DMA_STATUS_REG_1         0xD0
#define DMA_REQUEST_REG_0        0x09
#define DMA_REQUEST_REG_1        0xD2
#define DMA_SINGLE_CHANNEL_MASK_0 0x0A
#define DMA_SINGLE_CHANNEL_MASK_1 0xD4
#define DMA_MODE_REG_0           0x0B
#define DMA_MODE_REG_1           0xD6
#define DMA_FLIP_FLOP_RESET_0    0x0C
#define DMA_FLIP_FLOP_RESET_1    0xD8
#define DMA_INTERMEDIATE_REG_0   0x0D
#define DMA_INTERMEDIATE_REG_1   0xDA
#define DMA_MASTER_RESET_0       0x0D
#define DMA_MASTER_RESET_1       0xDA
#define DMA_MASK_RESET_0         0x0E
#define DMA_MASK_RESET_1         0xDC
#define DMA_MULTI_CHANNEL_MASK_0 0x0F
#define DMA_MULTI_CHANNEL_MASK_1 0xDE

// Page registers for DMA
#define DMA_PAGE_0               0x87  // Channel 0
#define DMA_PAGE_1               0x83  // Channel 1
#define DMA_PAGE_2               0x81  // Channel 2
#define DMA_PAGE_3               0x82  // Channel 3
#define DMA_PAGE_4               0x8F  // Channel 4
#define DMA_PAGE_5               0x8B  // Channel 5
#define DMA_PAGE_6               0x89  // Channel 6
#define DMA_PAGE_7               0x8A  // Channel 7

// DMA Transfer modes
#define DMA_MODE_DEMAND          0x00
#define DMA_MODE_SINGLE          0x40
#define DMA_MODE_BLOCK           0x80
#define DMA_MODE_CASCADE         0xC0

// DMA Transfer directions
#define DMA_MODE_VERIFY          0x00
#define DMA_MODE_WRITE           0x04  // Write to memory (read from device)
#define DMA_MODE_READ            0x08  // Read from memory (write to device)

// DMA Auto-init
#define DMA_MODE_AUTO_INIT       0x10

// DMA Address increment/decrement
#define DMA_MODE_INCREMENT       0x00
#define DMA_MODE_DECREMENT       0x20

// Maximum DMA transfer sizes
#define DMA_MAX_TRANSFER_8BIT    65536
#define DMA_MAX_TRANSFER_16BIT   131072

// DMA Buffer alignment requirements
#define DMA_BUFFER_ALIGNMENT     4096
#define DMA_MAX_BUFFER_SIZE      65536

// DMA Channel structure
typedef struct {
    uint8_t channel;
    bool is_16bit;
    bool in_use;
    uint32_t physical_address;
    uint32_t size;
    uint8_t mode;
    void (*completion_callback)(void* data);
    void* callback_data;
} dma_channel_t;

// DMA Buffer for AHCI/SATA operations
typedef struct {
    void* virtual_address;
    uint32_t physical_address;
    uint32_t size;
    bool allocated;
    uint8_t alignment_padding[16];  // Para alineaciÃ³n de 16 bytes
} dma_buffer_t;

// Physical Region Descriptor Table (PRDT) entry for DMA operations
typedef struct __attribute__((packed)) {
    uint32_t data_base_address;     // Data Base Address
    uint32_t data_base_address_upper; // Data Base Address Upper 32-bits
    uint32_t reserved;              // Reserved
    uint32_t byte_count : 22;       // Byte count (max 4MB)
    uint32_t reserved2 : 9;         // Reserved
    uint32_t interrupt_on_completion : 1; // Interrupt on completion
} dma_prdt_entry_t;

// DMA Descriptor for AHCI command
typedef struct {
    uint8_t command_fis[64];        // Command FIS
    uint8_t atapi_command[16];      // ATAPI Command
    uint8_t reserved[48];           // Reserved
    dma_prdt_entry_t prdt[1];         // Physical Region Descriptor Table
} ahci_command_table_t;

// Function prototypes
bool dma_init(void);
void dma_cleanup(void);

// ISA DMA functions
bool dma_setup_channel(uint8_t channel, uint32_t physical_addr, uint16_t size, uint8_t mode);
bool dma_start_transfer(uint8_t channel);
bool dma_stop_transfer(uint8_t channel);
uint16_t dma_get_transfer_count(uint8_t channel);
bool dma_is_transfer_complete(uint8_t channel);

// DMA Buffer management for AHCI
dma_buffer_t* dma_alloc_buffer(uint32_t size, uint32_t alignment);
void dma_free_buffer(dma_buffer_t* buffer);
bool dma_buffer_is_valid(dma_buffer_t* buffer);

// PRDT management
dma_prdt_entry_t* dma_create_prdt(void* data_buffer, uint32_t size, uint32_t max_entries);
void dma_free_prdt(dma_prdt_entry_t* prdt);

// Utility functions
uint32_t dma_virt_to_phys(void* virtual_addr);
void* dma_phys_to_virt(uint32_t physical_addr);
bool dma_address_is_dma_capable(uint32_t physical_addr);

// Debug functions
void dma_print_status(void);
void dma_test_basic_transfer(void);

#endif // DMA_H



================================================================================
FILE: installer.h
================================================================================

#ifndef INSTALLER_H
#define INSTALLER_H

#include <stdint.h>
#include <stdbool.h>
#include "disk.h"
#include "partition.h"
#include "vfs.h"

// Installation modes
typedef enum {
    INSTALL_MODE_FULL,         // Full installation (MBR + VBR + files)
    INSTALL_MODE_FILES_ONLY,   // Only copy files (safest)
    INSTALL_MODE_BOOTLOADER,   // Only install bootloader
    INSTALL_MODE_UPDATE        // Update existing installation
} install_mode_t;

// Installation options
typedef struct {
    install_mode_t mode;
    bool force;                // Force installation even if warnings
    bool verify;               // Verify after installation
    bool backup_mbr;           // Backup MBR before writing
    bool set_bootable;         // Set partition as bootable
    uint8_t target_partition;  // Target partition index (0-3)
} install_options_t;

// Installation image (from modules or pre-loaded)
typedef struct {
    // Bootloader components
    uint8_t *mbr_boot_code;       // MBR boot code (max 446 bytes)
    uint32_t mbr_boot_size;
    uint8_t *vbr_boot_code;       // VBR boot code (max 420 bytes)
    uint32_t vbr_boot_size;
    uint8_t *grub_core_img;       // GRUB core.img
    uint32_t grub_core_size;
    
    // Kernel and modules
    uint8_t *kernel_img;
    uint32_t kernel_size;
    uint8_t **module_imgs;        // Array of module images
    uint32_t *module_sizes;
    char **module_names;
    uint32_t module_count;
    
    // Configuration
    char *grub_cfg_content;
    char volume_label[12];
} installer_image_t;

// Installation state
typedef struct {
    disk_t *disk;
    partition_table_t pt;
    partition_info_t *target_partition;
    install_options_t options;
    installer_image_t *image;
    
    // State tracking
    bool mbr_backed_up;
    bool mbr_installed;
    bool vbr_installed;
    bool files_copied;
    bool grub_installed;
    bool is_partitionless;
    bool has_real_partitions;

    // Statistics
    uint32_t bytes_written;
    uint32_t files_written;
} installer_state_t;

// Error codes
typedef enum {
    INSTALL_OK = 0,
    INSTALL_ERR_INVALID_PARAM,
    INSTALL_ERR_DISK_ERROR,
    INSTALL_ERR_NO_PARTITION,
    INSTALL_ERR_PARTITION_TYPE,
    INSTALL_ERR_MOUNT_FAILED,
    INSTALL_ERR_WRITE_FAILED,
    INSTALL_ERR_VERIFY_FAILED,
    INSTALL_ERR_BACKUP_FAILED,
    INSTALL_ERR_MBR_INSTALL_FAILED,
    INSTALL_ERR_VBR_INSTALL_FAILED,
    INSTALL_ERR_FILE_COPY_FAILED,
    INSTALL_ERR_USER_ABORT
} install_err_t;

// Main installation functions
install_err_t installer_init(installer_state_t *state, disk_t *disk, 
                             installer_image_t *image, install_options_t *options);
install_err_t installer_analyze(installer_state_t *state);
install_err_t installer_install(installer_state_t *state);
install_err_t installer_verify(installer_state_t *state);
void installer_cleanup(installer_state_t *state);

// Step-by-step installation
install_err_t installer_backup_mbr(installer_state_t *state, uint8_t *backup_buffer);
install_err_t installer_install_mbr(installer_state_t *state);
install_err_t installer_install_vbr(installer_state_t *state);
install_err_t installer_copy_files(installer_state_t *state);
install_err_t installer_install_grub(installer_state_t *state);
install_err_t installer_create_grub_config(installer_state_t *state);

// Utility functions
install_err_t installer_format_partition(disk_t *disk, uint8_t partition_index, 
                                        const char *label);
install_err_t installer_mount_partition(installer_state_t *state, const char *mountpoint);
const char* installer_error_string(install_err_t error);
void installer_print_progress(installer_state_t *state);
void installer_print_summary(installer_state_t *state);
install_err_t installer_install_grub_proper(installer_state_t *state);

// Interactive installation
install_err_t installer_interactive(disk_t *disk, installer_image_t *image);

// Image loading from modules
install_err_t installer_load_image_from_modules(installer_image_t *image);
void installer_free_image(installer_image_t *image);
install_err_t install_os_complete(disk_t *disk, install_options_t *options);

#endif // INSTALLER_H



================================================================================
FILE: serial.h
================================================================================

#ifndef SERIAL_H
#define SERIAL_H

#include <stdint.h>
#include "kernel.h"
#include "isr.h"

// Puertos base para COM1 y COM2
#define COM1_BASE 0x3F8
#define COM2_BASE 0x2F8

// Offsets de registros UART 16550
#define UART_DATA   0x00  // RBR/THR
#define UART_DLL    0x00  // Divisor Latch Low (cuando DLAB=1)
#define UART_DLH    0x01  // Divisor Latch High (cuando DLAB=1)
#define UART_IER    0x01  // Interrupt Enable Register
#define UART_IIR    0x02  // Interrupt Identification Register (read)
#define UART_FCR    0x02  // FIFO Control Register (write)
#define UART_LCR    0x03  // Line Control Register
#define UART_MCR    0x04  // Modem Control Register
#define UART_LSR    0x05  // Line Status Register
#define UART_MSR    0x06  // Modem Status Register
#define UART_SCR    0x07  // Scratch Register

// Line Control Register bits
#define UART_LCR_DLAB    0x80 // Divisor Latch Access Bit
#define UART_LCR_8N1     0x03 // 8 bits, no parity, 1 stop bit

// Interrupt Enable Register bits
#define UART_IER_RX      0x01 // Enable Received Data Available Interrupt
#define UART_IER_THRE    0x02 // Enable Transmitter Holding Register Empty Interrupt

// Line Status Register bits
#define UART_LSR_DR      0x01 // Data Ready
#define UART_LSR_THRE    0x20 // Transmitter Holding Register Empty

// Modem Control Register bits
#define UART_MCR_DTR     0x01 // Data Terminal Ready
#define UART_MCR_RTS     0x02 // Request To Send
#define UART_MCR_OUT2    0x08 // OUT2 (necesario para interrupciones)

// FunciÃ³n para inicializar puertos seriales
void serial_init(void);

// Funciones para manejar interrupciones
void serial_irq_handler_line(int irq);

// Funciones de E/S
int serial_write_char(uint16_t port, char c);
void serial_write_string(uint16_t port, const char* str);
char serial_read_char(uint16_t port);
void serial_printf(uint16_t port, const char *fmt, ...);
int serial_can_write(uint16_t port);
int serial_can_read(uint16_t port);

#endif



================================================================================
FILE: atapi.h
================================================================================

#ifndef ATAPI_H
#define ATAPI_H

#include <stdint.h>
#include <stdbool.h>

// ATAPI Command Codes
#define ATAPI_CMD_TEST_UNIT_READY    0x00
#define ATAPI_CMD_REQUEST_SENSE      0x03
#define ATAPI_CMD_READ_10            0x28
#define ATAPI_CMD_READ_12            0xA8
#define ATAPI_CMD_READ_CAPACITY      0x25
#define ATAPI_CMD_READ_TOC           0x43
#define ATAPI_CMD_GET_CONFIGURATION  0x46
#define ATAPI_CMD_START_STOP_UNIT    0x1B
#define ATAPI_CMD_PREVENT_ALLOW      0x1E
#define ATAPI_CMD_INQUIRY            0x12

// ATAPI Packet sizes
#define ATAPI_PACKET_SIZE            12
#define ATAPI_SECTOR_SIZE            2048  // CD/DVD sector size

// ATAPI Device types
#define ATAPI_TYPE_CDROM             0x05
#define ATAPI_TYPE_TAPE              0x01
#define ATAPI_TYPE_DIRECT_ACCESS     0x00

// Maximum ATAPI devices
#define MAX_ATAPI_DEVICES            4

// IDE/ATA ports
#define ATA_PRIMARY_IO          0x1F0
#define ATA_PRIMARY_CTRL        0x3F6
#define ATA_SECONDARY_IO        0x170
#define ATA_SECONDARY_CTRL      0x376
// ATAPI Error codes
typedef enum {
    ATAPI_ERR_NONE = 0,
    ATAPI_ERR_INVALID_PARAM,
    ATAPI_ERR_NOT_INITIALIZED,
    ATAPI_ERR_NO_MEDIA,
    ATAPI_ERR_TIMEOUT,
    ATAPI_ERR_IO_ERROR,
    ATAPI_ERR_DEVICE_NOT_READY,
    ATAPI_ERR_LBA_OUT_OF_RANGE,
    ATAPI_ERR_NOT_SUPPORTED
} atapi_err_t;

// ATAPI Sense Key codes
typedef enum {
    ATAPI_SENSE_NO_SENSE        = 0x0,
    ATAPI_SENSE_RECOVERED_ERROR = 0x1,
    ATAPI_SENSE_NOT_READY       = 0x2,
    ATAPI_SENSE_MEDIUM_ERROR    = 0x3,
    ATAPI_SENSE_HARDWARE_ERROR  = 0x4,
    ATAPI_SENSE_ILLEGAL_REQUEST = 0x5,
    ATAPI_SENSE_UNIT_ATTENTION  = 0x6,
    ATAPI_SENSE_DATA_PROTECT    = 0x7,
    ATAPI_SENSE_ABORTED_COMMAND = 0xB
} atapi_sense_key_t;

// ATAPI Device structure
typedef struct {
    uint8_t device_id;          // Device ID (0-3)
    uint8_t bus;                // IDE bus (0 or 1)
    uint8_t drive;              // Drive select (0=master, 1=slave)
    bool present;               // Device present
    bool initialized;           // Device initialized
    bool media_present;         // Media inserted
    
    // Device information
    uint8_t device_type;        // ATAPI device type
    char model[41];             // Device model
    char serial[21];            // Device serial number
    char firmware[9];           // Firmware version
    
    // Media information
    uint32_t sector_count;      // Total sectors on media
    uint32_t sector_size;       // Sector size (usually 2048)
    bool media_changed;         // Media change flag
    
    // I/O ports
    uint16_t io_base;           // Base I/O port
    uint16_t io_ctrl;           // Control port
    
    // Statistics
    uint64_t read_count;        // Read operations
    uint64_t error_count;       // Error count
} atapi_device_t;

// ATAPI Sense data structure
typedef struct {
    uint8_t error_code;
    uint8_t sense_key;
    uint32_t information;
    uint8_t asc;                // Additional Sense Code
    uint8_t ascq;               // Additional Sense Code Qualifier
} atapi_sense_data_t;

// Function prototypes

// Initialization and detection
bool atapi_init(void);
void atapi_cleanup(void);
bool atapi_detect_device(uint8_t bus, uint8_t drive);
bool atapi_identify_device(atapi_device_t* device);

// Device operations
atapi_err_t atapi_read_sectors(uint32_t device_id, uint32_t lba, uint32_t count, void* buffer);
atapi_err_t atapi_test_unit_ready(uint32_t device_id);
atapi_err_t atapi_read_capacity(uint32_t device_id, uint32_t* sector_count, uint32_t* sector_size);
atapi_err_t atapi_request_sense(uint32_t device_id, atapi_sense_data_t* sense);

// Media control
atapi_err_t atapi_eject(uint32_t device_id);
atapi_err_t atapi_load(uint32_t device_id);
bool atapi_check_media(uint32_t device_id);

// Information and utilities
uint32_t atapi_get_device_count(void);
atapi_device_t* atapi_get_device_info(uint32_t device_id);
void atapi_list_devices(void);
const char* atapi_get_error_string(atapi_err_t error);
const char* atapi_get_sense_key_string(atapi_sense_key_t sense_key);
bool atapi_verify_device_signature(uint8_t bus, uint8_t drive);
// Low-level packet interface
atapi_err_t atapi_send_packet(atapi_device_t* device, uint8_t* packet, 
                              void* buffer, uint32_t buffer_size, bool read);

#endif // ATAPI_H



================================================================================
FILE: text_editor.h
================================================================================

#ifndef TEXT_EDITOR_H
#define TEXT_EDITOR_H

#include "keyboard.h"
#include "terminal.h"
#include <stdbool.h>
#include <stdint.h>

// ConfiguraciÃ³n del editor
#define EDITOR_MAX_LINES 1024
#define EDITOR_LINE_MAX_LENGTH 256
#define EDITOR_TAB_SIZE 4
#define EDITOR_STATUS_HEIGHT 2
#define EDITOR_BUFFER_SIZE (EDITOR_MAX_LINES * EDITOR_LINE_MAX_LENGTH)

// Modos del editor
typedef enum {
  EDITOR_MODE_NORMAL,  // NavegaciÃ³n y comandos
  EDITOR_MODE_INSERT,  // InserciÃ³n de texto
  EDITOR_MODE_COMMAND, // Modo de comandos (lÃ­nea inferior)
  EDITOR_MODE_SEARCH,  // BÃºsqueda
  EDITOR_MODE_REPLACE, // Reemplazo
  EDITOR_MODE_HELP     // Ayuda
} editor_mode_t;

// Estructura de una lÃ­nea de texto
typedef struct editor_line {
  char data[EDITOR_LINE_MAX_LENGTH];
  uint32_t length;
  bool modified;
} editor_line_t;

// Estructura principal del editor
typedef struct text_editor {
  // Buffer de lÃ­neas
  editor_line_t *lines;
  uint32_t line_count;
  uint32_t max_lines;

  // Cursor
  uint32_t cursor_x; // Columna (carÃ¡cter)
  uint32_t cursor_y; // LÃ­nea

  // Viewport (porciÃ³n visible de texto)
  uint32_t viewport_x; // Primera columna visible
  uint32_t viewport_y; // Primera lÃ­nea visible
  uint32_t viewport_width;
  uint32_t viewport_height;

  // Terminal asociado
  Terminal *term;

  // Archivo
  char filename[256];
  int file_descriptor;
  bool file_open;
  bool modified;

  // Modo actual
  editor_mode_t mode;

  // Buffer de comandos
  char command_buffer[256];
  uint32_t command_length;

  // Buffer del portapapeles
  char clipboard[EDITOR_LINE_MAX_LENGTH];
  uint32_t clipboard_length;

  // BÃºsqueda
  char search_term[128];
  uint32_t search_length;

  // Estado
  bool running;
  char status_message[256];
  uint32_t status_time;

} text_editor_t;

// Funciones pÃºblicas del editor
text_editor_t *editor_create(Terminal *term);
void editor_destroy(text_editor_t *editor);

// Operaciones de archivo
int editor_open_file(text_editor_t *editor, const char *filename);
int editor_save_file(text_editor_t *editor);
int editor_save_as(text_editor_t *editor, const char *filename);
void editor_close_file(text_editor_t *editor);

// Operaciones de ediciÃ³n
void editor_insert_char(text_editor_t *editor, char c);
void editor_delete_char(text_editor_t *editor);
void editor_backspace(text_editor_t *editor);
void editor_insert_newline(text_editor_t *editor);
void editor_delete_line(text_editor_t *editor);
void editor_mark_line_dirty(text_editor_t *editor, uint32_t line);

// NavegaciÃ³n
void editor_move_cursor(text_editor_t *editor, int dx, int dy);
void editor_move_cursor_home(text_editor_t *editor);
void editor_move_cursor_end(text_editor_t *editor);
void editor_page_up(text_editor_t *editor);
void editor_page_down(text_editor_t *editor);
void editor_goto_line(text_editor_t *editor, uint32_t line);

// Operaciones de texto
void editor_copy_line(text_editor_t *editor);
void editor_cut_line(text_editor_t *editor);
void editor_paste(text_editor_t *editor);
void editor_undo(text_editor_t *editor);

// BÃºsqueda
void editor_search(text_editor_t *editor, const char *term);
void editor_search_next(text_editor_t *editor);

// Interfaz
void editor_render(text_editor_t *editor);
void editor_render_status_bar(text_editor_t *editor);
void editor_set_status_message(text_editor_t *editor, const char *message);
void editor_process_key(text_editor_t *editor, int key);
void editor_process_key_normal(text_editor_t *editor, int key);
void editor_process_key_insert(text_editor_t *editor, int key);
void editor_process_key_command(text_editor_t *editor, int key);
void editor_process_key_search(text_editor_t *editor, int key);
void editor_execute_command(text_editor_t *editor, const char *cmd);
void editor_show_help(text_editor_t *editor);

// Callback de teclado
void editor_keyboard_callback(int key);
void editor_set_active(text_editor_t *editor);

// Bucle principal
void editor_run(text_editor_t *editor);

// Utilidades
uint32_t editor_get_line_display_length(const char *line, uint32_t length);
void editor_scroll_if_needed(text_editor_t *editor);

#endif // TEXT_EDITOR_H



================================================================================
FILE: fat32.h
================================================================================

#ifndef FAT32_H
#define FAT32_H

#include "disk.h"
#include "vfs.h"
#include <stdbool.h>
#include <stdint.h>

// FAT32 constants
#define FAT32_SECTOR_SIZE 512
#define FAT32_MAX_FILENAME 255
#define FAT32_DIR_ENTRY_SIZE 32
#define FAT32_ENTRIES_PER_SECTOR (FAT32_SECTOR_SIZE / FAT32_DIR_ENTRY_SIZE)
#define FAT32_EOC 0x0FFFFFF8               // End of chain marker
#define FAT32_BAD_CLUSTER 0x0FFFFFF7       // Bad cluster marker
#define FAT32_FREE_CLUSTER 0x00000000      // Free cluster marker
#define FAT32_RESERVED_CLUSTER 0x0FFFFFF0  // Reserved cluster marker
#define FAT32_CLN_SHUT_BIT_MASK 0x08000000 // Bit 27: 1 = clean, 0 = dirty
#define FAT32_HRD_ERR_BIT_MASK 0x04000000  // Bit 26: 1 = no errors, 0 = errors

// Directory entry attributes
#define FAT32_ATTR_READ_ONLY 0x01
#define FAT32_ATTR_HIDDEN 0x02
#define FAT32_ATTR_SYSTEM 0x04
#define FAT32_ATTR_VOLUME_ID 0x08
#define FAT32_ATTR_DIRECTORY 0x10
#define FAT32_ATTR_ARCHIVE 0x20
#define FAT32_ATTR_LONG_NAME                                                   \
  (FAT32_ATTR_READ_ONLY | FAT32_ATTR_HIDDEN | FAT32_ATTR_SYSTEM |              \
   FAT32_ATTR_VOLUME_ID)

// Formatting constants
#define FAT32_DEFAULT_SECTORS_PER_CLUSTER 8
#define FAT32_DEFAULT_NUM_FATS 2
#define FAT32_MAX_VOLUME_LABEL 11
#define FAT32_AUTO_SPC 0

// Boot sector structure (packed)
typedef struct __attribute__((packed)) {
  uint8_t jmp_boot[3];         // Jump instruction
  uint8_t oem_name[8];         // OEM name
  uint16_t bytes_per_sector;   // Bytes per sector
  uint8_t sectors_per_cluster; // Sectors per cluster
  uint16_t reserved_sectors;   // Reserved sectors
  uint8_t num_fats;            // Number of FATs
  uint16_t root_entries;       // Root directory entries (0 for FAT32)
  uint16_t total_sectors_16;   // Total sectors (0 for FAT32)
  uint8_t media_type;          // Media type
  uint16_t sectors_per_fat_16; // Sectors per FAT (0 for FAT32)
  uint16_t sectors_per_track;  // Sectors per track
  uint16_t num_heads;          // Number of heads
  uint32_t hidden_sectors;     // Hidden sectors
  uint32_t total_sectors_32;   // Total sectors

  // FAT32 specific fields
  uint32_t sectors_per_fat_32;    // Sectors per FAT
  uint16_t ext_flags;             // Extended flags
  uint16_t fs_version;            // Filesystem version
  uint32_t root_cluster;          // Root directory cluster
  uint16_t fs_info_sector;        // FSInfo sector
  uint16_t backup_boot_sector;    // Backup boot sector
  uint8_t reserved[12];           // Reserved
  uint8_t drive_number;           // Drive number
  uint8_t reserved1;              // Reserved
  uint8_t boot_signature;         // Boot signature
  uint32_t volume_id;             // Volume ID
  uint8_t volume_label[11];       // Volume label
  uint8_t fs_type[8];             // Filesystem type
  uint8_t boot_code[420];         // Boot code
  uint16_t boot_sector_signature; // Boot sector signature (0xAA55)
} fat32_boot_sector_t;

// FSInfo sector structure (packed)
typedef struct __attribute__((packed)) {
  uint32_t lead_signature;    // Lead signature (0x41615252)
  uint8_t reserved[480];      // Reserved
  uint32_t struct_signature;  // Structure signature (0x61417272)
  uint32_t free_clusters;     // Free cluster count
  uint32_t next_free_cluster; // Next free cluster
  uint8_t reserved2[12];      // Reserved
  uint32_t trail_signature;   // Trail signature (0xAA550000)
} fat32_fsinfo_t;

// Directory entry structure (packed)
typedef struct __attribute__((packed)) {
  uint8_t name[11];            // Short name (8.3 format)
  uint8_t attributes;          // File attributes
  uint8_t nt_reserved;         // Reserved for Windows NT
  uint8_t creation_time_tenth; // Creation time (tenths of second)
  uint16_t creation_time;      // Creation time
  uint16_t creation_date;      // Creation date
  uint16_t last_access_date;   // Last access date
  uint16_t first_cluster_high; // High word of first cluster
  uint16_t write_time;         // Write time
  uint16_t write_date;         // Write date
  uint16_t first_cluster_low;  // Low word of first cluster
  uint32_t file_size;          // File size in bytes
} fat32_dir_entry_t;

// Long filename entry structure (packed)
typedef struct __attribute__((packed)) {
  uint8_t order;          // Order of this entry
  uint16_t name1[5];      // First 5 characters (Unicode)
  uint8_t attributes;     // Attributes (always FAT32_ATTR_LONG_NAME)
  uint8_t type;           // Type (always 0)
  uint8_t checksum;       // Checksum of short name
  uint16_t name2[6];      // Next 6 characters (Unicode)
  uint16_t first_cluster; // First cluster (always 0)
  uint16_t name3[2];      // Last 2 characters (Unicode)
} fat32_lfn_entry_t;

// FAT32 filesystem private data
typedef struct {
  disk_t *disk;                    // Backing disk device
  fat32_boot_sector_t boot_sector; // Boot sector
  fat32_fsinfo_t fsinfo;           // FSInfo sector

  // Calculated values
  uint32_t fat_start_sector;  // First FAT sector
  uint32_t data_start_sector; // First data sector
  uint32_t root_dir_cluster;  // Root directory cluster
  uint32_t cluster_size;      // Cluster size in bytes
  uint32_t total_clusters;    // Total number of clusters

  // Cache for FAT table
  uint32_t *fat_cache;       // Cached FAT entries
  uint32_t fat_cache_sector; // Currently cached FAT sector
  uint8_t fat_cache_dirty;   // FAT cache dirty flag

  // Directory entry cache
  uint8_t *dir_cache;        // Directory sector cache
  uint32_t dir_cache_sector; // Currently cached directory sector
  uint8_t dir_cache_dirty;   // Directory cache dirty flag

  // Nueva: Flag para errores
  uint8_t has_errors; // 1 si hubo errores, 0 si no
} fat32_fs_t;

// FAT32 vnode private data
typedef struct {
  uint32_t first_cluster;   // First cluster of file/directory
  uint32_t size;            // File size (0 for directories)
  uint32_t current_cluster; // Current cluster for sequential access
  uint32_t cluster_offset;  // Offset within current cluster
  uint8_t attributes;       // File attributes
  uint8_t is_directory;     // 1 if directory, 0 if file
  uint32_t parent_cluster;  // Cluster of the parent directory (0 for root)
  uint8_t short_name[11];   // Short 8.3 name for locating dir entry
} fat32_node_t;

// Function prototypes
extern vfs_fs_type_t fat32_fs_type;

// Internal functions
int fat32_mount(void *device, vfs_superblock_t **out_sb);
int fat32_read_boot_sector(fat32_fs_t *fs);
int fat32_read_fsinfo(fat32_fs_t *fs);
uint32_t fat32_get_fat_entry(fat32_fs_t *fs, uint32_t cluster);
int fat32_set_fat_entry(fat32_fs_t *fs, uint32_t cluster, uint32_t value);
uint32_t fat32_allocate_cluster(fat32_fs_t *fs);
int fat32_free_cluster_chain(fat32_fs_t *fs, uint32_t cluster);
uint32_t fat32_cluster_to_sector(fat32_fs_t *fs, uint32_t cluster);
int fat32_read_cluster(fat32_fs_t *fs, uint32_t cluster, void *buffer);
int fat32_write_cluster(fat32_fs_t *fs, uint32_t cluster, const void *buffer);
int fat32_update_fsinfo(fat32_fs_t *fs); // Cambiado de void a int
int fat32_update_dir_entry(fat32_fs_t *fs, fat32_node_t *node_data);
static int
fat32_is_directory_empty(fat32_fs_t *fs,
                         uint32_t dir_cluster); // Nueva: declaraciÃ³n static
int fat32_validate_cluster_chain(fat32_fs_t *fs, uint32_t first_cluster,
                                 uint32_t *out_chain_length);

// VFS operations
int fat32_lookup(vfs_node_t *parent, const char *name, vfs_node_t **out);
int fat32_create(vfs_node_t *parent, const char *name, vfs_node_t **out);
int fat32_read(vfs_node_t *node, uint8_t *buf, uint32_t size, uint32_t offset);
int fat32_write(vfs_node_t *node, const uint8_t *buf, uint32_t size,
                uint32_t offset);
int fat32_readdir(vfs_node_t *node, vfs_dirent_t *buf, uint32_t *count,
                  uint32_t offset);
void fat32_release(vfs_node_t *node);
int fat32_mkdir(vfs_node_t *parent, const char *name, vfs_node_t **out);
int fat32_unlink(vfs_node_t *parent, const char *name);

// Utility functions
int fat32_parse_short_name(const char *name, uint8_t *fat_name);
int fat32_format_short_name(const uint8_t *fat_name, char *name);
uint8_t fat32_calculate_checksum(const uint8_t *short_name);
bool check_fat32_signature(uint8_t *boot_sector);
int fat32_find_free_dir_entry(fat32_fs_t *fs, uint32_t dir_cluster,
                              uint32_t *sector, uint32_t *offset);
int fat32_create_dir_entry(fat32_fs_t *fs, uint32_t dir_cluster,
                           const char *name, uint32_t first_cluster,
                           uint32_t size, uint8_t attributes);
int fat32_calculate_free_clusters(fat32_fs_t *fs, uint32_t *free_clusters,
                                  uint32_t *next_free_cluster);

// CACHE HANDLING
int fat32_flush_fat_cache(fat32_fs_t *fs);
int fat32_flush_dir_cache(fat32_fs_t *fs);

// Test
int create_large_file(const char *path);

// Formatting functions
int fat32_format(disk_t *disk, const char *volume_label);
int fat32_format_with_params(disk_t *disk, uint16_t sectors_per_cluster,
                             uint8_t num_fats, const char *volume_label);

#endif // FAT32_H




================================================================================
FILE: task_utils.h
================================================================================

#ifndef TASK_UTILS_H
#define TASK_UTILS_H

#include "task.h"
#include "kernel.h"
#include "memory.h"
#include "terminal.h"
#include "string.h"

// ========================================================================
// MACROS DE TESTING
// ========================================================================

#define TEST_START(name) \
    do { \
        terminal_printf(&main_terminal, "\r\n[TEST] %s...", name); \
    } while(0)

#define TEST_PASS() \
    do { \
        terminal_puts(&main_terminal, " PASS"); \
        tests_passed++; \
    } while(0)

#define TEST_FAIL(reason) \
    do { \
        terminal_printf(&main_terminal, " FAIL: %s", reason); \
        tests_failed++; \
    } while(0)

#define TEST_ASSERT(condition, reason) \
    do { \
        if (!(condition)) { \
            TEST_FAIL(reason); \
            return; \
        } \
    } while(0)

#define TEST_ASSERT_FORMAT(condition, reason, ...) \
    do { \
        if (!(condition)) { \
            snprintf(test_output, sizeof(test_output), reason, ##__VA_ARGS__); \
            TEST_FAIL(test_output); \
            return; \
        } \
    } while(0)

// ========================================================================
// ESTRUCTURA MUTEX (MEJORADA)
// ========================================================================

typedef struct {
    volatile bool locked;
    task_t* owner;
    uint32_t lock_count;  // âœ… NUEVO: Para locks reentrantes
    const char* name;
} mutex_t;

// Funciones de sincronizaciÃ³n
void mutex_init(mutex_t* mutex, const char* name);
bool mutex_try_lock(mutex_t* mutex);
void mutex_lock(mutex_t* mutex);
void mutex_unlock(mutex_t* mutex);

// ========================================================================
// SISTEMA DE MENSAJES
// ========================================================================

#define MAX_MESSAGE_QUEUES 16
#define MAX_MESSAGES_PER_QUEUE 32
#define MAX_MESSAGE_SIZE 256

typedef struct message {
    uint32_t sender_id;
    uint32_t type;
    size_t size;
    uint8_t data[MAX_MESSAGE_SIZE];
    struct message* next;
} message_t;

typedef struct {
    uint32_t owner_task_id;
    message_t* head;
    message_t* tail;
    uint32_t message_count;
    mutex_t queue_mutex;
    volatile bool has_messages;
} message_queue_t;

// Funciones de mensajes
void message_system_init(void);
message_queue_t* message_queue_create(uint32_t task_id);
message_queue_t* message_queue_get(uint32_t task_id);  // âœ… NUEVO
bool message_send(uint32_t target_task_id, uint32_t type, const void* data, size_t size);
bool message_receive(message_t* msg_out, bool blocking);
void message_queue_destroy(message_queue_t* queue);

// ========================================================================
// PROFILING
// ========================================================================

void task_profiling_enable(void);
void task_profiling_disable(void);
void task_profiling_update(task_t* task, uint32_t runtime_ticks);
void task_profiling_report(void);

// ========================================================================
// MONITOREO Y DEBUGGING
// ========================================================================

void task_monitor_health(void);
void task_cleanup_zombies(void);
void task_dump_context(task_t* task);

#endif // TASK_UTILS_H



================================================================================
FILE: mmu.h
================================================================================

#ifndef MMU_H
#define MMU_H

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>

// Flags de pÃ¡gina
#define PAGE_PRESENT 0x001
#define PAGE_RW 0x002
#define PAGE_USER 0x004
#define PAGE_WRITETHROUGH 0x008
#define PAGE_CACHE_DISABLE 0x010
#define PAGE_ACCESSED 0x020
#define PAGE_DIRTY 0x040
#define PAGE_GLOBAL 0x100
#define PAGE_4MB 0x080 // Para pÃ¡ginas grandes (4MB)

// Constantes
#define PAGE_DIRECTORY_ENTRIES 1024
#define PAGE_TABLE_ENTRIES 1024
#define PAGE_SIZE 4096
#define PAGE_SIZE_4MB (4 * 1024 * 1024)
#define KERNEL_VIRTUAL_BASE 0xC0000000 // 3GB
#define FRAMEBUFFER_BASE 0xE0000000
// Niveles de privilegio
#define KERNEL_PRIVILEGE 0
#define USER_PRIVILEGE 3
#define MODULE_VIRTUAL_BASE 0xF0000000

// Estructura para direcciones virtuales/fÃ­sicas
typedef struct {
  uint32_t virtual_addr;
  uint32_t physical_addr;
  uint32_t size;
  uint32_t flags;
} memory_map_t;

// Macros de alineaciÃ³n
#define ALIGN_4KB_DOWN(addr) ((addr) & ~0xFFF)
#define ALIGN_4KB_UP(addr) (((addr) + 0xFFF) & ~0xFFF)
#define ALIGN_4MB_DOWN(addr) ((addr) & ~0x3FFFFF)
#define ALIGN_4MB_UP(addr) (((addr) + 0x3FFFFF) & ~0x3FFFFF)

// Prototipos de funciones
void mmu_init(void);
void mmu_transition_to_higher_half(void);
void mmu_init_higher_half(void);
bool mmu_remove_identity_mapping(void);
void mmu_prepare_higher_half_transition(void);
void mmu_audit_identity_references(void);
void mmu_load_cr3(uint32_t pd_phys_addr);
void mmu_enable_paging(void);
bool mmu_map_page(uint32_t virtual_addr, uint32_t physical_addr,
                  uint32_t flags);
bool mmu_unmap_page(uint32_t virtual_addr);
bool mmu_map_region(uint32_t virtual_start, uint32_t physical_start,
                    uint32_t size, uint32_t flags);
bool mmu_unmap_region(uint32_t virtual_start, uint32_t size);
bool mmu_set_flags(uint32_t virtual_addr, uint32_t flags);
uint32_t mmu_virtual_to_physical(uint32_t virtual_addr);
bool mmu_is_mapped(uint32_t virtual_addr);

// Funciones de prueba
void mmu_run_tests(void);
bool mmu_test_basic_mapping(void);
bool mmu_test_region_mapping(void);
bool mmu_test_permissions(void);
bool mmu_ensure_physical_mapped(uint32_t phys_start, uint32_t size);
bool mmu_verify_mapping(uint32_t virtual_addr, uint32_t size);
uint32_t mmu_find_virtual_for_physical(uint32_t phys_addr);
bool mmu_ensure_physical_accessible(uint32_t phys_start, uint32_t size,
                                    uint32_t *virt_addr);

// Funciones para modo usuario
void mmu_switch_to_user_pd(uint32_t user_pd);
uint32_t mmu_get_kernel_pd(void);
bool mmu_copy_kernel_mappings(uint32_t *user_pd);
uint32_t mmu_get_current_cr3(void);
uint32_t mmu_get_page_flags(uint32_t virtual_addr);
bool mmu_set_page_user(uint32_t virtual_addr);
bool mmu_can_user_access(uint32_t virtual_addr, bool write);

// Variables globales
extern uint32_t page_directory[PAGE_DIRECTORY_ENTRIES];
extern uint32_t page_tables[PAGE_DIRECTORY_ENTRIES][PAGE_TABLE_ENTRIES];
extern uint32_t used_page_tables[PAGE_DIRECTORY_ENTRIES];

#endif // MMU_H



================================================================================
FILE: usb_uhci.h
================================================================================

#ifndef USB_UHCI_H
#define USB_UHCI_H

#include "usb_core.h"
#include "dma.h"

// UHCI Register Offsets
#define UHCI_REG_USBCMD     0x00
#define UHCI_REG_USBSTS     0x02
#define UHCI_REG_USBINTR    0x04
#define UHCI_REG_FRNUM      0x06
#define UHCI_REG_FRBASEADD  0x08
#define UHCI_REG_SOFMOD     0x0C
#define UHCI_REG_PORTSC1    0x10
#define UHCI_REG_PORTSC2    0x12

// UHCI Command Register Bits
#define UHCI_CMD_RS         (1 << 0)  // Run/Stop
#define UHCI_CMD_HCRESET    (1 << 1)  // Host Controller Reset
#define UHCI_CMD_GRESET     (1 << 2)  // Global Reset
#define UHCI_CMD_EGSM       (1 << 3)  // Enter Global Suspend Mode
#define UHCI_CMD_FGR        (1 << 4)  // Force Global Resume
#define UHCI_CMD_SWDBG      (1 << 5)  // Software Debug
#define UHCI_CMD_CF         (1 << 6)  // Configure Flag
#define UHCI_CMD_MAXP       (1 << 7)  // Max Packet (64 bytes)

// UHCI Status Register Bits
#define UHCI_STS_USBINT     (1 << 0)  // USB Interrupt
#define UHCI_STS_ERROR      (1 << 1)  // USB Error Interrupt
#define UHCI_STS_RD         (1 << 2)  // Resume Detect
#define UHCI_STS_HSE        (1 << 3)  // Host System Error
#define UHCI_STS_HCPE       (1 << 4)  // Host Controller Process Error
#define UHCI_STS_HCH        (1 << 5)  // HC Halted

// Port Status Bits
#define UHCI_PORT_CCS       (1 << 0)  // Current Connect Status
#define UHCI_PORT_CSC       (1 << 1)  // Connect Status Change
#define UHCI_PORT_PE        (1 << 2)  // Port Enable
#define UHCI_PORT_PEC       (1 << 3)  // Port Enable Change
#define UHCI_PORT_LS        (3 << 4)  // Line Status
#define UHCI_PORT_RD        (1 << 6)  // Resume Detect
#define UHCI_PORT_LSDA      (1 << 8)  // Low Speed Device Attached
#define UHCI_PORT_PR        (1 << 9)  // Port Reset
#define UHCI_PORT_SUSP      (1 << 12) // Suspend

// Transfer Descriptor (TD) bits
#define UHCI_TD_ACTLEN_MASK 0x7FF
#define UHCI_TD_STATUS_MASK 0xFF
#define UHCI_TD_SPD         (1 << 29) // Short Packet Detect
#define UHCI_TD_LS          (1 << 26) // Low Speed
#define UHCI_TD_IOC         (1 << 24) // Interrupt on Complete
#define UHCI_TD_ACTIVE      (1 << 23) // Active
#define UHCI_TD_STALLED     (1 << 22) // Stalled
#define UHCI_TD_DBUF        (1 << 21) // Data Buffer Error
#define UHCI_TD_BABBLE      (1 << 20) // Babble Detected
#define UHCI_TD_NAK         (1 << 19) // NAK Received
#define UHCI_TD_CRCTO       (1 << 18) // CRC/Time Out Error
#define UHCI_TD_BITSTUFF    (1 << 17) // Bit Stuff Error

// PID tokens
#define UHCI_PID_SETUP      0x2D
#define UHCI_PID_IN         0x69
#define UHCI_PID_OUT        0xE1

#define UHCI_FRAME_LIST_SIZE 1024

// UHCI Transfer Descriptor
typedef struct uhci_td {
    uint32_t link_ptr;
    uint32_t status;
    uint32_t token;
    uint32_t buffer;
    
    // Software-only fields
    uint32_t reserved[4];
} __attribute__((packed, aligned(16))) uhci_td_t;

// UHCI Queue Head
typedef struct uhci_qh {
    uint32_t head_link_ptr;
    uint32_t element_link_ptr;
    
    // Software-only fields
    uint32_t reserved[14];
} __attribute__((packed, aligned(16))) uhci_qh_t;

// UHCI Controller Data
typedef struct {
    uint16_t io_base;
    
    dma_buffer_t* frame_list_buffer;
    uint32_t* frame_list;
    
    dma_buffer_t* qh_buffer;
    uhci_qh_t* control_qh;
    uhci_qh_t* bulk_qh;
    
    dma_buffer_t* td_pool_buffer;
    uhci_td_t* td_pool;
    bool td_used[64];
} uhci_data_t;

// Function prototypes
bool uhci_init(usb_controller_t* controller);
void uhci_cleanup(usb_controller_t* controller);
bool uhci_detect_ports(usb_controller_t* controller);
bool uhci_reset_port(usb_controller_t* controller, uint8_t port);

// Transfer functions
bool uhci_control_transfer(usb_device_t* device, usb_setup_packet_t* setup,
                           void* data, uint16_t length);
bool uhci_bulk_transfer(usb_device_t* device, uint8_t endpoint,
                        void* data, uint32_t length, bool is_in);

// Internal functions
uhci_td_t* uhci_alloc_td(uhci_data_t* uhci);
void uhci_free_td(uhci_data_t* uhci, uhci_td_t* td);
bool uhci_wait_for_td(uhci_td_t* td, uint32_t timeout_ms);

#endif // USB_UHCI_H



================================================================================
FILE: pci.h
================================================================================

#ifndef PCI_H
#define PCI_H

#include <stdint.h>
#include <stdbool.h>

// Puertos PCI Configuration Space
#define PCI_CONFIG_ADDRESS 0xCF8
#define PCI_CONFIG_DATA    0xCFC

// Offsets en el Configuration Space
#define PCI_VENDOR_ID      0x00
#define PCI_DEVICE_ID      0x02
#define PCI_COMMAND        0x04
#define PCI_STATUS         0x06
#define PCI_REVISION_ID    0x08
#define PCI_PROG_IF        0x09
#define PCI_SUBCLASS       0x0A
#define PCI_CLASS_CODE     0x0B
#define PCI_CACHE_LINE_SIZE 0x0C
#define PCI_LATENCY_TIMER  0x0D
#define PCI_HEADER_TYPE    0x0E
#define PCI_BIST           0x0F
#define PCI_BAR0           0x10
#define PCI_BAR1           0x14
#define PCI_BAR2           0x18
#define PCI_BAR3           0x1C
#define PCI_BAR4           0x20
#define PCI_BAR5           0x24
#define PCI_INTERRUPT_LINE 0x3C
#define PCI_INTERRUPT_PIN  0x3D

// Bits del comando PCI
#define PCI_COMMAND_IO          0x0001
#define PCI_COMMAND_MEMORY      0x0002
#define PCI_COMMAND_MASTER      0x0004
#define PCI_COMMAND_SPECIAL     0x0008
#define PCI_COMMAND_INVALIDATE  0x0010
#define PCI_COMMAND_VGA_PALETTE 0x0020
#define PCI_COMMAND_PARITY      0x0040
#define PCI_COMMAND_WAIT        0x0080
#define PCI_COMMAND_SERR        0x0100
#define PCI_COMMAND_FAST_BACK   0x0200
#define PCI_COMMAND_INTX_DISABLE 0x0400

// Tipos de BAR
#define PCI_BAR_TYPE_MEMORY     0x00
#define PCI_BAR_TYPE_IO         0x01
#define PCI_BAR_MEMORY_32BIT    0x00
#define PCI_BAR_MEMORY_64BIT    0x04
#define PCI_BAR_PREFETCHABLE    0x08

// Clases de dispositivos PCI comunes
#define PCI_CLASS_UNCLASSIFIED  0x00
#define PCI_CLASS_STORAGE       0x01
#define PCI_CLASS_NETWORK       0x02
#define PCI_CLASS_DISPLAY       0x03
#define PCI_CLASS_MULTIMEDIA    0x04
#define PCI_CLASS_MEMORY        0x05
#define PCI_CLASS_BRIDGE        0x06
#define PCI_CLASS_COMMUNICATION 0x07
#define PCI_CLASS_SYSTEM        0x08
#define PCI_CLASS_INPUT         0x09
#define PCI_CLASS_DOCKING       0x0A
#define PCI_CLASS_PROCESSOR     0x0B
#define PCI_CLASS_SERIAL_BUS    0x0C

// MÃ¡ximo nÃºmero de dispositivos PCI a enumerar
#define MAX_PCI_DEVICES 256

// Estructura para informaciÃ³n de BAR
typedef struct {
    uint32_t address;
    uint32_t size;
    uint8_t type;        // 0 = memory, 1 = I/O
    bool is_64bit;
    bool is_prefetchable;
    bool is_valid;
} pci_bar_t;

// Estructura de dispositivo PCI
typedef struct {
    uint8_t bus;
    uint8_t device;
    uint8_t function;
    
    uint16_t vendor_id;
    uint16_t device_id;
    uint8_t class_code;
    uint8_t subclass;
    uint8_t prog_if;
    uint8_t revision_id;
    
    uint8_t header_type;
    uint8_t interrupt_line;
    uint8_t interrupt_pin;
    
    pci_bar_t bars[6];
    
    bool present;
} pci_device_t;

// Tabla global de dispositivos PCI
extern pci_device_t pci_devices[MAX_PCI_DEVICES];
extern uint32_t pci_device_count;

// Funciones principales
void pci_init(void);
uint32_t pci_config_read_dword(uint8_t bus, uint8_t device, uint8_t function, uint8_t offset);
uint16_t pci_config_read_word(uint8_t bus, uint8_t device, uint8_t function, uint8_t offset);
uint8_t pci_config_read_byte(uint8_t bus, uint8_t device, uint8_t function, uint8_t offset);
void pci_config_write_dword(uint8_t bus, uint8_t device, uint8_t function, uint8_t offset, uint32_t data);
void pci_config_write_word(uint8_t bus, uint8_t device, uint8_t function, uint8_t offset, uint16_t data);
void pci_config_write_byte(uint8_t bus, uint8_t device, uint8_t function, uint8_t offset, uint8_t data);

// Funciones de enumeraciÃ³n
void pci_scan_all_buses(void);
void pci_scan_bus(uint8_t bus);
void pci_scan_device(uint8_t bus, uint8_t device);
void pci_scan_function(uint8_t bus, uint8_t device, uint8_t function);

// Funciones de utilidad
pci_device_t* pci_find_device(uint16_t vendor_id, uint16_t device_id);
pci_device_t* pci_find_device_by_class(uint8_t class_code, uint8_t subclass);
void pci_enable_bus_mastering(pci_device_t* device);
void pci_enable_memory_space(pci_device_t* device);
void pci_enable_io_space(pci_device_t* device);
uint32_t pci_get_bar_size(uint8_t bus, uint8_t device, uint8_t function, uint8_t bar_num);
void pci_read_bars(pci_device_t* device);

// Funciones de informaciÃ³n
void pci_list_devices(void);
const char* pci_get_class_name(uint8_t class_code);
const char* pci_get_vendor_name(uint16_t vendor_id);

#endif // PCI_H



================================================================================
FILE: log.h
================================================================================

#ifndef LOG_H
#define LOG_H

#include <stdint.h>
#include "task_utils.h"
#include "vfs.h"

// Constantes
#define LOG_MAX_MESSAGE_SIZE 512
#define LOG_DEFAULT_PATH "/ramfs/syslog.log"

// Niveles de log
typedef enum {
    LOG_INFO,
    LOG_WARN,
    LOG_ERROR
} log_level_t;

// Funciones
void log_init(void);
void log_set_path(const char *new_path);
void log_message(log_level_t level, const char *format, ...);
int log_read(char *buffer, uint32_t size, uint32_t offset);
void log_test(void);

#endif



================================================================================
FILE: drawing.h
================================================================================

#ifndef DRAWING_H
#define DRAWING_H

#include <stddef.h>
#include <stdint.h>
#include "math_utils.h"

// Definiciones de colores (formato 0xRRGGBB)
#define COLOR_BLACK         0x000000
#define COLOR_WHITE         0xFFFFFF
#define COLOR_RED           0xFF0000
#define COLOR_GREEN         0x00FF00
#define COLOR_BLUE          0x0000FF
#define COLOR_YELLOW        0xFFFF00
#define COLOR_CYAN          0x00FFFF
#define COLOR_MAGENTA       0xFF00FF
#define COLOR_GRAY          0x808080
#define COLOR_DARK_GRAY     0x404040
#define COLOR_ORANGE        0xFFA500
#define COLOR_TRANSPARENT   0xFFFFFFFF
#define COLOR_LIGHT_RED     0xFF6666
#define COLOR_LIGHT_GREEN   0x66FF66
#define COLOR_LIGHT_BLUE    0x6666FF
#define COLOR_LIGHT_YELLOW  0xFFFF66
#define COLOR_LIGHT_CYAN    0x66FFFF
#define COLOR_LIGHT_MAGENTA 0xFF66FF
#define COLOR_DARK_RED      0x660000
#define COLOR_DARK_GREEN    0x006600
#define COLOR_DARK_BLUE     0x000066
#define COLOR_DARK_YELLOW   0x666600
#define COLOR_DARK_CYAN     0x006666
#define COLOR_DARK_MAGENTA  0x660066
#define COLOR_BROWN         0x996633
#define COLOR_OLIVE         0x808000
#define COLOR_PURPLE        0x800080
#define COLOR_TEAL          0x008080
#define COLOR_NAVY          0x000080
#define COLOR_MAROON        0x800000
#define COLOR_LIME          0x00FF00
#define COLOR_AQUA          0x00FFFF
#define COLOR_FUCHSIA       0xFF00FF
#define COLOR_SILVER        0xC0C0C0

// Estructura para pÃ­xeles en formato 24bpp
typedef struct {
    uint8_t blue;
    uint8_t green;
    uint8_t red;
} __attribute__((packed)) Pixel24;

// Estructura del framebuffer
typedef struct {
    uint32_t* buffer32;    // Para 32bpp
    Pixel24* buffer24;     // Para 24bpp
    uint32_t width;
    uint32_t height;
    uint32_t pitch;        // En bytes
    uint32_t bpp;          // Bits por pÃ­xel (24 o 32)
} Framebuffer;

// Tipos de fuente disponibles
typedef enum {
    FONT_8x8_BASIC,
    FONT_8x8_BOLD,
    FONT_8x16_VGA,
    FONT_6x8_SLIM,
    FONT_8x16_TERMINUS,
    FONT_12x16_SANS,
    FONT_16x32_LARGE
} FontType;

typedef struct {
    const void* glyphs;  // Puntero genÃ©rico a los glifos
    uint8_t width;
    uint8_t height;
    uint8_t spacing;
    uint8_t bytes_per_glyph;  // Bytes por glifo (para saber cÃ³mo acceder)
} FontInfo;

// Variables globales del framebuffer
extern Framebuffer g_fb;
extern uint32_t g_fg_color;
extern uint32_t g_bg_color;
extern uint32_t g_cursor_x;
extern uint32_t g_cursor_y;
extern FontInfo g_current_font;

// Funciones de inicializaciÃ³n
void fb_init(void* framebuffer, uint32_t width, uint32_t height, uint32_t pitch_bytes, uint32_t bpp);
void set_font(FontType font_type);
void set_colors(uint32_t fg, uint32_t bg);

// Funciones bÃ¡sicas de dibujo
void put_pixel(uint32_t x, uint32_t y, uint32_t color);
void fill_rect(uint32_t x, uint32_t y, uint32_t w, uint32_t h, uint32_t color);
void draw_rect(uint32_t x, uint32_t y, uint32_t w, uint32_t h, uint32_t color);
void draw_rounded_rect(uint32_t x, uint32_t y, uint32_t w, uint32_t h, uint32_t radius, uint32_t color);
void fill_rounded_rect(uint32_t x, uint32_t y, uint32_t w, uint32_t h, uint32_t radius, uint32_t color);
void draw_line(uint32_t x0, uint32_t y0, uint32_t x1, uint32_t y1, uint32_t color);
void draw_thick_line(uint32_t x0, uint32_t y0, uint32_t x1, uint32_t y1, uint32_t thickness, uint32_t color);
void draw_circle(uint32_t x0, uint32_t y0, uint32_t radius, uint32_t color);
void fill_circle(uint32_t x0, uint32_t y0, uint32_t radius, uint32_t color);
void draw_circle_quarter(uint32_t x0, uint32_t y0, uint32_t radius, uint8_t quarter, uint32_t color);
void draw_arc(uint32_t x0, uint32_t y0, uint32_t radius, float start_angle, float end_angle, uint32_t color);
void draw_triangle(uint32_t x0, uint32_t y0, uint32_t x1, uint32_t y1, uint32_t x2, uint32_t y2, uint32_t color);
void fill_triangle(uint32_t x0, uint32_t y0, uint32_t x1, uint32_t y1, uint32_t x2, uint32_t y2, uint32_t color);
void draw_scanline(int32_t x1, int32_t x2, int32_t y, uint32_t color);

// Funciones de texto
void put_char(char c);
void put_string(const char* str);
void draw_string(uint32_t x, uint32_t y, const char* str, uint32_t fg_color, uint32_t bg_color);
void set_cursor_pos(uint32_t x, uint32_t y);
void clear_screen();
void scroll_screen();

// Funciones de dibujo avanzado
void draw_bitmap(uint32_t x, uint32_t y, uint32_t w, uint32_t h, const uint8_t* bitmap, uint32_t color);
void draw_color_bitmap(uint32_t x, uint32_t y, uint32_t w, uint32_t h, const uint32_t* bitmap);
void draw_rounded_button(uint32_t x, uint32_t y, uint32_t w, uint32_t h, uint32_t radius, const char* text, uint32_t color);
void draw_big_char(uint32_t x, uint32_t y, char c, uint32_t scale, uint32_t fg_color, uint32_t bg_color);
void draw_big_string(uint32_t x, uint32_t y, const char* str, uint32_t scale, uint32_t fg_color, uint32_t bg_color);
void draw_char(uint32_t x, uint32_t y, char c, uint32_t fg_color, uint32_t bg_color);
void draw_char_with_shadow(uint32_t x, uint32_t y, char c, uint32_t fg_color, uint32_t bg_color, uint32_t shadow_color, uint8_t shadow_offset);
void draw_string_with_shadow(uint32_t x, uint32_t y, const char* str, uint32_t fg_color, uint32_t bg_color, uint32_t shadow_color, uint8_t shadow_offset);
int printf(const char *format, ...);

#endif // DRAWING_H



================================================================================
FILE: mini_parser.h
================================================================================

#ifndef MINI_PARSER_H
#define MINI_PARSER_H

#include "task.h"
#include "vfs.h"
#include "string.h"
#include "memory.h"
#include "terminal.h"

#define MAX_PROGRAM_SIZE    (64 * 1024)  // 64KB mÃ¡ximo por programa
#define MAX_LABELS          256
#define MAX_LINE_LENGTH     256
#define MAX_STACK_SIZE      (8 * 1024)   // 8KB stack para programas

// Tipos de instrucciones soportadas
typedef enum {
    OP_NOP = 0,
    OP_MOV,
    OP_ADD,
    OP_SUB,
    OP_MUL,
    OP_DIV,
    OP_CMP,
    OP_JMP,
    OP_JE,
    OP_JNE,
    OP_JG,
    OP_JL,
    OP_CALL,
    OP_RET,
    OP_PUSH,
    OP_POP,
    OP_PRINT,
    OP_PRINT_INT,
    OP_PRINT_STR,
    OP_READ_INT,
    OP_READ_STR,
    OP_EXIT,
    OP_SLEEP,
    OP_YIELD,
    OP_OPEN,
    OP_READ,
    OP_WRITE,
    OP_CLOSE,
    OP_SEEK
} opcode_t;

// Tipos de operandos
typedef enum {
    OP_TYPE_NONE = 0,
    OP_TYPE_REG,
    OP_TYPE_IMM,
    OP_TYPE_MEM,
    OP_TYPE_LABEL,
    OP_TYPE_STRING
} operand_type_t;

// Registros virtuales
typedef enum {
    REG_A = 0,
    REG_B,
    REG_C,
    REG_D,
    REG_SP,
    REG_PC,
    REG_FLAGS,
    REG_COUNT
} register_t;

// Flags
#define FLAG_ZERO       (1 << 0)
#define FLAG_CARRY      (1 << 1)
#define FLAG_SIGN       (1 << 2)

// Estructura de operando
typedef struct {
    operand_type_t type;
    union {
        int32_t imm_value;        // Valor inmediato
        register_t reg;           // Registro
        uint32_t mem_addr;        // DirecciÃ³n de memoria
        char* string_literal;     // Literal de string
        char* label_name;         // Nombre de label
    };
} operand_t;

// Estructura de instrucciÃ³n
typedef struct {
    opcode_t opcode;
    operand_t operands[3];        // Hasta 3 operandos
    uint32_t line_number;
    char* original_line;
} instruction_t;

// Estructura del programa
typedef struct {
    instruction_t* instructions;
    uint32_t instruction_count;
    uint32_t data_size;
    uint8_t* data_section;
    
    // Tabla de labels
    struct {
        char name[64];
        uint32_t instruction_index;
    } labels[MAX_LABELS];
    uint32_t label_count;
    
    // Memoria del programa
    uint8_t* memory;
    uint32_t memory_size;
    
    // Registros virtuales
    int32_t registers[REG_COUNT];
    
    // Stack
    uint8_t* stack;
    uint32_t stack_size;
    
    // Estado
    uint8_t running;
    int32_t exit_code;
    
    // Archivos abiertos
    int open_files[16];
    
    // Entrada/salida
    char output_buffer[1024];
    uint32_t output_pos;
    
} mini_program_t;

// Funciones pÃºblicas
int mini_parser_load_file(const char* filename, mini_program_t* program);
int mini_parser_execute(mini_program_t* program);
void mini_parser_cleanup(mini_program_t* program);
task_t* mini_parser_create_task(const char* filename, const char* task_name);
void mini_program_task_wrapper(void* arg);

// Funciones de parsing
int mini_parser_parse_source(const char* source, mini_program_t* program);
int mini_parser_parse_instruction(const char* line, instruction_t* instr);
int mini_parser_parse_operand(const char* token, operand_t* operand);
int mini_parser_read_line(const char** src_ptr, char* line, size_t max_len);
void mini_parser_trim_whitespace(char* str);

// Funciones de ejecuciÃ³n
int mini_parser_execute_instruction(mini_program_t* program, instruction_t* instr);
int32_t mini_parser_get_operand_value(mini_program_t* program, operand_t* op);
int mini_parser_set_operand_value(mini_program_t* program, operand_t* op, int32_t value);
uint32_t mini_parser_resolve_label(mini_program_t* program, operand_t* op);

// Implementaciones de instrucciones
int mini_parser_op_mov(mini_program_t* program, instruction_t* instr);
int mini_parser_op_add(mini_program_t* program, instruction_t* instr);
int mini_parser_op_sub(mini_program_t* program, instruction_t* instr);
int mini_parser_op_mul(mini_program_t* program, instruction_t* instr);
int mini_parser_op_div(mini_program_t* program, instruction_t* instr);
int mini_parser_op_cmp(mini_program_t* program, instruction_t* instr);
int mini_parser_op_jmp(mini_program_t* program, instruction_t* instr);
int mini_parser_op_je(mini_program_t* program, instruction_t* instr);
int mini_parser_op_jne(mini_program_t* program, instruction_t* instr);
int mini_parser_op_call(mini_program_t* program, instruction_t* instr);
int mini_parser_op_ret(mini_program_t* program, instruction_t* instr);
int mini_parser_op_push(mini_program_t* program, instruction_t* instr);
int mini_parser_op_pop(mini_program_t* program, instruction_t* instr);
int mini_parser_op_print(mini_program_t* program, instruction_t* instr);
int mini_parser_op_print_int(mini_program_t* program, instruction_t* instr);
int mini_parser_op_print_str(mini_program_t* program, instruction_t* instr);
int mini_parser_op_exit(mini_program_t* program, instruction_t* instr);
int mini_parser_op_sleep(mini_program_t* program, instruction_t* instr);
int mini_parser_op_jg(mini_program_t* program, instruction_t* instr);  // NUEVO
int mini_parser_op_jl(mini_program_t* program, instruction_t* instr);  // NUEVO

// Funciones de depuraciÃ³n
void mini_parser_disassemble(mini_program_t* program);
void mini_parser_dump_registers(mini_program_t* program);

#endif



================================================================================
FILE: usb_core.h
================================================================================

#ifndef USB_CORE_H
#define USB_CORE_H

#include <stdint.h>
#include <stdbool.h>
#include "pci.h"

// USB Classes
#define USB_CLASS_MASS_STORAGE  0x08
#define USB_CLASS_HUB           0x09

// USB Request Types
#define USB_REQ_GET_STATUS      0x00
#define USB_REQ_CLEAR_FEATURE   0x01
#define USB_REQ_SET_FEATURE     0x03
#define USB_REQ_SET_ADDRESS     0x05
#define USB_REQ_GET_DESCRIPTOR  0x06
#define USB_REQ_SET_DESCRIPTOR  0x07
#define USB_REQ_GET_CONFIGURATION 0x08
#define USB_REQ_SET_CONFIGURATION 0x09

// USB Descriptor Types
#define USB_DESC_DEVICE         0x01
#define USB_DESC_CONFIGURATION  0x02
#define USB_DESC_STRING         0x03
#define USB_DESC_INTERFACE      0x04
#define USB_DESC_ENDPOINT       0x05

// USB Speeds
#define USB_SPEED_LOW           0
#define USB_SPEED_FULL          1
#define USB_SPEED_HIGH          2

// USB Controller Types
#define USB_TYPE_UHCI           0  // USB 1.1
#define USB_TYPE_OHCI           1  // USB 1.1 (alternate)
#define USB_TYPE_EHCI           2  // USB 2.0
#define USB_TYPE_XHCI           3  // USB 3.0

#define USB_MAX_CONTROLLERS     8
#define USB_MAX_DEVICES         32
#define USB_MAX_ENDPOINTS       16

// USB Device Descriptor
typedef struct __attribute__((packed)) {
    uint8_t  bLength;
    uint8_t  bDescriptorType;
    uint16_t bcdUSB;
    uint8_t  bDeviceClass;
    uint8_t  bDeviceSubClass;
    uint8_t  bDeviceProtocol;
    uint8_t  bMaxPacketSize0;
    uint16_t idVendor;
    uint16_t idProduct;
    uint16_t bcdDevice;
    uint8_t  iManufacturer;
    uint8_t  iProduct;
    uint8_t  iSerialNumber;
    uint8_t  bNumConfigurations;
} usb_device_descriptor_t;

// USB Configuration Descriptor
typedef struct __attribute__((packed)) {
    uint8_t  bLength;
    uint8_t  bDescriptorType;
    uint16_t wTotalLength;
    uint8_t  bNumInterfaces;
    uint8_t  bConfigurationValue;
    uint8_t  iConfiguration;
    uint8_t  bmAttributes;
    uint8_t  bMaxPower;
} usb_config_descriptor_t;

// USB Interface Descriptor
typedef struct __attribute__((packed)) {
    uint8_t bLength;
    uint8_t bDescriptorType;
    uint8_t bInterfaceNumber;
    uint8_t bAlternateSetting;
    uint8_t bNumEndpoints;
    uint8_t bInterfaceClass;
    uint8_t bInterfaceSubClass;
    uint8_t bInterfaceProtocol;
    uint8_t iInterface;
} usb_interface_descriptor_t;

// USB Endpoint Descriptor
typedef struct __attribute__((packed)) {
    uint8_t  bLength;
    uint8_t  bDescriptorType;
    uint8_t  bEndpointAddress;
    uint8_t  bmAttributes;
    uint16_t wMaxPacketSize;
    uint8_t  bInterval;
} usb_endpoint_descriptor_t;

// USB Setup Packet
typedef struct __attribute__((packed)) {
    uint8_t  bmRequestType;
    uint8_t  bRequest;
    uint16_t wValue;
    uint16_t wIndex;
    uint16_t wLength;
} usb_setup_packet_t;

// USB Device
typedef struct {
    uint8_t address;
    uint8_t speed;
    uint8_t controller_id;
    uint8_t port;
    bool connected;
    
    usb_device_descriptor_t descriptor;
    uint8_t config_value;
    
    uint8_t class_code;
    uint8_t subclass;
    uint8_t protocol;
    
    void* driver_data;  // Driver-specific data
    
    uint8_t ep_toggles[32];  // Added: Index = (ep_num & 0x0F) + (is_in ? 16 : 0); 0=OUT, 1=IN directions
} usb_device_t;

// USB Controller
typedef struct {
    uint8_t type;
    uint8_t id;
    pci_device_t* pci_dev;
    void* regs;
    uint32_t regs_physical;
    bool initialized;
    
    usb_device_t devices[USB_MAX_DEVICES];
    uint8_t device_count;
} usb_controller_t;

// USB Driver Interface
typedef struct {
    const char* name;
    uint8_t class_code;
    uint8_t subclass;
    uint8_t protocol;
    
    bool (*probe)(usb_device_t* device);
    bool (*init)(usb_device_t* device);
    void (*cleanup)(usb_device_t* device);
} usb_driver_t;

// Global USB state
extern usb_controller_t usb_controllers[USB_MAX_CONTROLLERS];
extern uint8_t usb_controller_count;

// Core functions
bool usb_init(void);
void usb_cleanup(void);
usb_controller_t* usb_detect_controllers(void);

// Device management
usb_device_t* usb_allocate_device(usb_controller_t* controller);
bool usb_enumerate_device(usb_controller_t* controller, uint8_t port);
void usb_remove_device(usb_device_t* device);

// Transfer functions (controller-specific, implemented by each driver)
bool usb_control_transfer(usb_device_t* device, usb_setup_packet_t* setup, 
                          void* data, uint16_t length);
bool usb_bulk_transfer(usb_device_t* device, uint8_t endpoint, 
                       void* data, uint32_t length, bool is_in);

// Descriptor functions
bool usb_get_device_descriptor(usb_device_t* device);
bool usb_get_config_descriptor(usb_device_t* device, uint8_t config_index, 
                               void* buffer, uint16_t length);
bool usb_set_configuration(usb_device_t* device, uint8_t config_value);
bool usb_set_address(usb_device_t* device, uint8_t address);

// Driver registration
bool usb_register_driver(usb_driver_t* driver);
void usb_scan_for_drivers(usb_device_t* device);
bool usb_clear_endpoint_halt(usb_device_t* device, uint8_t endpoint);

// Utility functions
void usb_list_devices(void);
const char* usb_get_class_name(uint8_t class_code);
const char* usb_get_speed_name(uint8_t speed);

#endif // USB_CORE_H



================================================================================
FILE: mbr.h
================================================================================

#ifndef MBR_H
#define MBR_H

#include <stdint.h>
#include <stdbool.h>
#include "disk.h"
#include "partition.h"

// Boot signature
#define BOOT_SIGNATURE 0xAA55

// MBR boot code size
#define MBR_BOOT_CODE_SIZE 446

// VBR (Volume Boot Record) for FAT32
typedef struct __attribute__((packed)) {
    uint8_t  jump[3];              // Jump instruction
    uint8_t  oem_name[8];          // OEM name
    uint16_t bytes_per_sector;     // Bytes per sector
    uint8_t  sectors_per_cluster;  // Sectors per cluster
    uint16_t reserved_sectors;     // Reserved sectors
    uint8_t  num_fats;             // Number of FATs
    uint16_t root_entries;         // Root entries (0 for FAT32)
    uint16_t total_sectors_16;     // Total sectors (0 for FAT32)
    uint8_t  media_type;           // Media type
    uint16_t sectors_per_fat_16;   // Sectors per FAT (0 for FAT32)
    uint16_t sectors_per_track;    // Sectors per track
    uint16_t num_heads;            // Number of heads
    uint32_t hidden_sectors;       // Hidden sectors
    uint32_t total_sectors_32;     // Total sectors
    uint32_t sectors_per_fat_32;   // Sectors per FAT
    uint16_t ext_flags;            // Extended flags
    uint16_t fs_version;           // Filesystem version
    uint32_t root_cluster;         // Root directory cluster
    uint16_t fs_info_sector;       // FSInfo sector
    uint16_t backup_boot_sector;   // Backup boot sector
    uint8_t  reserved[12];         // Reserved
    uint8_t  drive_number;         // Drive number
    uint8_t  reserved1;            // Reserved
    uint8_t  boot_signature;       // Boot signature (0x29)
    uint32_t volume_id;            // Volume ID
    uint8_t  volume_label[11];     // Volume label
    uint8_t  fs_type[8];           // Filesystem type
    uint8_t  boot_code[420];       // Boot code
    uint16_t signature;            // Boot signature (0xAA55)
} vbr_fat32_t;

// Error codes
typedef enum {
    MBR_OK = 0,
    MBR_ERR_INVALID_DISK,
    MBR_ERR_READ_FAILED,
    MBR_ERR_WRITE_FAILED,
    MBR_ERR_INVALID_SIGNATURE,
    MBR_ERR_BUFFER_TOO_SMALL,
    MBR_ERR_VERIFY_FAILED
} mbr_err_t;

// Functions for MBR
mbr_err_t mbr_read(disk_t *disk, mbr_t *mbr);
mbr_err_t mbr_write(disk_t *disk, const mbr_t *mbr);
mbr_err_t mbr_install_bootcode(disk_t *disk, const uint8_t *boot_code, uint32_t size);
mbr_err_t mbr_backup(disk_t *disk, uint8_t *backup_buffer, uint32_t buffer_size);
mbr_err_t mbr_restore(disk_t *disk, const uint8_t *backup_buffer, uint32_t buffer_size);
bool mbr_verify_signature(const mbr_t *mbr);

// Functions for VBR (Volume Boot Record)
mbr_err_t vbr_read(disk_t *disk, uint64_t partition_lba, vbr_fat32_t *vbr);
mbr_err_t vbr_write(disk_t *disk, uint64_t partition_lba, const vbr_fat32_t *vbr);
mbr_err_t vbr_install_bootcode(disk_t *disk, uint64_t partition_lba, 
                                const uint8_t *boot_code, uint32_t size);
bool vbr_verify_fat32(const vbr_fat32_t *vbr);

// Utility functions
void mbr_print_hex(const uint8_t *data, uint32_t size);

#endif // MBR_H



================================================================================
FILE: disk_io_daemon.h
================================================================================

// ========================================================================
// disk_io_daemon.h
// ========================================================================

#ifndef DISK_IO_DAEMON_H
#define DISK_IO_DAEMON_H

#include "disk.h"

// Inicializar el daemon
void disk_io_daemon_init(void);

// FunciÃ³n principal del daemon (no llamar directamente)
void disk_io_daemon(void* arg);

// API pÃºblica para I/O asÃ­ncrono
disk_err_t async_disk_read(disk_t* disk, uint64_t lba, uint32_t count, void* buffer);
disk_err_t async_disk_write(disk_t* disk, uint64_t lba, uint32_t count, const void* buffer);
disk_err_t async_disk_flush(disk_t* disk);

void cmd_async_read_test(void);
void cmd_async_write_test(void);

#endif // DISK_IO_DAEMON_H


================================================================================
FILE: usb_disk_wrapper.h
================================================================================

#ifndef USB_DISK_WRAPPER_H
#define USB_DISK_WRAPPER_H

#include "disk.h"
#include "usb_mass_storage.h"

// USB disk IDs start at 0xF0 to avoid conflicts with other disks
#define USB_DISK_BASE_ID 0xF0

// Initialize USB disk wrapper system
void usb_disk_init_system(void);

// Scan for USB storage devices
void usb_scan_for_storage(void);

// Initialize a disk_t structure for a USB device
disk_err_t usb_disk_init(disk_t* disk, uint32_t usb_device_id);

// Get number of USB storage devices
uint32_t usb_disk_get_count(void);

// Disk operations for USB devices
disk_err_t usb_disk_read(disk_t* disk, uint64_t lba, uint32_t count, void* buffer);
disk_err_t usb_disk_write(disk_t* disk, uint64_t lba, uint32_t count, const void* buffer);
disk_err_t usb_disk_flush(disk_t* disk);

// Helper to check if a disk_t is a USB disk
bool disk_is_usb(disk_t* disk);

#endif // USB_DISK_WRAPPER_H



================================================================================
FILE: keyboard.h
================================================================================

#ifndef KEYBOARD_H
#define KEYBOARD_H

#include <stddef.h>
#include <stdint.h>

// DefiniciÃ³n del layout de teclado
typedef struct keyboard_layout {
  char name[32];
  uint8_t normal[128];
  uint8_t shift[128];
  uint8_t altgr[128];
} keyboard_layout_t;

typedef void (*EditorKeyHandler)(int key, void *context);

#define KEYBOARD_DATA_PORT 0x60
#define KEYBOARD_STATUS_PORT 0x64
#define RELEASE_MASK 0x80

// CÃ³digos de teclas especiales
#define KEY_UP (-1)
#define KEY_DOWN (-2)
#define KEY_LEFT (-3)
#define KEY_RIGHT (-4)
#define KEY_HOME (-5)
#define KEY_END (-6)
#define KEY_PGUP (-7)
#define KEY_PGDOWN (-8)
#define KEY_INSERT (-9)
#define KEY_DELETE (-10)

// Teclas de funciÃ³n
#define KEY_F1 0x3B
#define KEY_F2 0x3C
#define KEY_F3 0x3D
#define KEY_F4 0x3E
#define KEY_F5 0x3F
#define KEY_F6 0x40
#define KEY_F7 0x41
#define KEY_F8 0x42
#define KEY_F9 0x43
#define KEY_F10 0x44
#define KEY_F11 0x57
#define KEY_F12 0x58

// Teclas modificadoras
#define LEFT_SHIFT 0x2A
#define RIGHT_SHIFT 0x36
#define LEFT_CTRL 0x1D
#define LEFT_ALT 0x38
#define CAPS_LOCK 0x3A
#define RIGHT_ALT 0xE038 // Extended scancode for Right Alt (AltGr)

typedef struct {
  uint8_t left_shift;
  uint8_t right_shift;
  uint8_t ctrl;
  uint8_t alt;
  uint8_t altgr; // Nuevo: Para Right Alt (AltGr)
  uint8_t caps_lock;
  uint8_t last_key_processed;
} KeyboardState;

void keyboard_init();
uint8_t keyboard_read_scancode();
int keyboard_process_scancode(uint8_t scancode, KeyboardState *state,
                              uint8_t *extended_flag);
uint8_t keyboard_get_modifiers(KeyboardState *state);
void keyboard_irq_handler(void);
typedef void (*KeyboardCallback)(int key);
void keyboard_set_handler(KeyboardCallback handler);
int keyboard_get_char(void);
int keyboard_wait_char(void);

// Nuevas funciones para integraciÃ³n con el sistema de drivers
keyboard_layout_t *keyboard_get_current_layout(void);
int keyboard_set_layout(const char *layout_name);
int keyboard_load_layout(const char *filename, const char *layout_name);

int keyboard_available(void);
int keyboard_getkey_nonblock(void);
void keyboard_clear_buffer(void);

#endif



================================================================================
FILE: cpuid.h
================================================================================

#ifndef CPUID_H
#define CPUID_H

#include "terminal.h"
#include <stdbool.h>
#include <stdint.h>


// ========================================================================
// CPUID FUNCTION NUMBERS
// ========================================================================

#define CPUID_GETVENDORSTRING 0x00
#define CPUID_GETFEATURES 0x01
#define CPUID_GETCACHE 0x02
#define CPUID_GETSERIAL 0x03
#define CPUID_GETTLB 0x04
#define CPUID_GETEXTENDEDFEATURES 0x07
#define CPUID_INTELEXTENDED 0x80000000
#define CPUID_INTELFEATURES 0x80000001
#define CPUID_INTELBRANDSTRING 0x80000002
#define CPUID_INTELBRANDSTRINGMORE 0x80000003
#define CPUID_INTELBRANDSTRINGEND 0x80000004

// ========================================================================
// FEATURE FLAGS - ECX (Function 0x01)
// ========================================================================

#define CPUID_FEAT_ECX_SSE3 (1 << 0)
#define CPUID_FEAT_ECX_PCLMUL (1 << 1)
#define CPUID_FEAT_ECX_DTES64 (1 << 2)
#define CPUID_FEAT_ECX_MONITOR (1 << 3)
#define CPUID_FEAT_ECX_DS_CPL (1 << 4)
#define CPUID_FEAT_ECX_VMX (1 << 5)
#define CPUID_FEAT_ECX_SMX (1 << 6)
#define CPUID_FEAT_ECX_EST (1 << 7)
#define CPUID_FEAT_ECX_TM2 (1 << 8)
#define CPUID_FEAT_ECX_SSSE3 (1 << 9)
#define CPUID_FEAT_ECX_CID (1 << 10)
#define CPUID_FEAT_ECX_FMA (1 << 12)
#define CPUID_FEAT_ECX_CX16 (1 << 13)
#define CPUID_FEAT_ECX_ETPRD (1 << 14)
#define CPUID_FEAT_ECX_PDCM (1 << 15)
#define CPUID_FEAT_ECX_PCIDE (1 << 17)
#define CPUID_FEAT_ECX_DCA (1 << 18)
#define CPUID_FEAT_ECX_SSE4_1 (1 << 19)
#define CPUID_FEAT_ECX_SSE4_2 (1 << 20)
#define CPUID_FEAT_ECX_x2APIC (1 << 21)
#define CPUID_FEAT_ECX_MOVBE (1 << 22)
#define CPUID_FEAT_ECX_POPCNT (1 << 23)
#define CPUID_FEAT_ECX_AES (1 << 25)
#define CPUID_FEAT_ECX_XSAVE (1 << 26)
#define CPUID_FEAT_ECX_OSXSAVE (1 << 27)
#define CPUID_FEAT_ECX_AVX (1 << 28)
#define CPUID_FEAT_ECX_F16C (1 << 29)
#define CPUID_FEAT_ECX_RDRAND (1 << 30)

// ========================================================================
// FEATURE FLAGS - EDX (Function 0x01)
// ========================================================================

#define CPUID_FEAT_EDX_FPU (1 << 0)
#define CPUID_FEAT_EDX_VME (1 << 1)
#define CPUID_FEAT_EDX_DE (1 << 2)
#define CPUID_FEAT_EDX_PSE (1 << 3)
#define CPUID_FEAT_EDX_TSC (1 << 4)
#define CPUID_FEAT_EDX_MSR (1 << 5)
#define CPUID_FEAT_EDX_PAE (1 << 6)
#define CPUID_FEAT_EDX_MCE (1 << 7)
#define CPUID_FEAT_EDX_CX8 (1 << 8)
#define CPUID_FEAT_EDX_APIC (1 << 9)
#define CPUID_FEAT_EDX_SEP (1 << 11)
#define CPUID_FEAT_EDX_MTRR (1 << 12)
#define CPUID_FEAT_EDX_PGE (1 << 13)
#define CPUID_FEAT_EDX_MCA (1 << 14)
#define CPUID_FEAT_EDX_CMOV (1 << 15)
#define CPUID_FEAT_EDX_PAT (1 << 16)
#define CPUID_FEAT_EDX_PSE36 (1 << 17)
#define CPUID_FEAT_EDX_PSN (1 << 18)
#define CPUID_FEAT_EDX_CLF (1 << 19)
#define CPUID_FEAT_EDX_DTES (1 << 21)
#define CPUID_FEAT_EDX_ACPI (1 << 22)
#define CPUID_FEAT_EDX_MMX (1 << 23)
#define CPUID_FEAT_EDX_FXSR (1 << 24)
#define CPUID_FEAT_EDX_SSE (1 << 25)
#define CPUID_FEAT_EDX_SSE2 (1 << 26)
#define CPUID_FEAT_EDX_SS (1 << 27)
#define CPUID_FEAT_EDX_HTT (1 << 28)
#define CPUID_FEAT_EDX_TM1 (1 << 29)
#define CPUID_FEAT_EDX_IA64 (1 << 30)
#define CPUID_FEAT_EDX_PBE (1 << 31)

// ========================================================================
// EXTENDED FEATURE FLAGS - EBX (Function 0x07, ECX=0)
// ========================================================================

#define CPUID_FEAT_EXT_FSGSBASE (1 << 0)
#define CPUID_FEAT_EXT_TSC_ADJUST (1 << 1)
#define CPUID_FEAT_EXT_SGX (1 << 2)
#define CPUID_FEAT_EXT_BMI1 (1 << 3)
#define CPUID_FEAT_EXT_HLE (1 << 4)
#define CPUID_FEAT_EXT_AVX2 (1 << 5)
#define CPUID_FEAT_EXT_SMEP (1 << 7)
#define CPUID_FEAT_EXT_BMI2 (1 << 8)
#define CPUID_FEAT_EXT_ERMS (1 << 9)
#define CPUID_FEAT_EXT_INVPCID (1 << 10)
#define CPUID_FEAT_EXT_RTM (1 << 11)
#define CPUID_FEAT_EXT_MPX (1 << 14)
#define CPUID_FEAT_EXT_AVX512F (1 << 16)
#define CPUID_FEAT_EXT_RDSEED (1 << 18)
#define CPUID_FEAT_EXT_ADX (1 << 19)
#define CPUID_FEAT_EXT_SMAP (1 << 20)
#define CPUID_FEAT_EXT_CLFLUSHOPT (1 << 23)
#define CPUID_FEAT_EXT_CLWB (1 << 24)
#define CPUID_FEAT_EXT_SHA (1 << 29)

// ========================================================================
// EXTENDED FEATURE FLAGS - ECX (Function 0x80000001)
// ========================================================================

#define CPUID_FEAT_EXT_LAHF_LM (1 << 0) // LAHF/SAHF in long mode
#define CPUID_FEAT_EXT_CMP_LEGACY (1 << 1)
#define CPUID_FEAT_EXT_SVM (1 << 2) // AMD SVM
#define CPUID_FEAT_EXT_EXTAPIC (1 << 3)
#define CPUID_FEAT_EXT_CR8_LEGACY (1 << 4)
#define CPUID_FEAT_EXT_ABM (1 << 5) // Advanced bit manipulation
#define CPUID_FEAT_EXT_SSE4A (1 << 6)
#define CPUID_FEAT_EXT_MISALIGNSSE (1 << 7)
#define CPUID_FEAT_EXT_3DNOWPREFETCH (1 << 8)
#define CPUID_FEAT_EXT_OSVW (1 << 9)
#define CPUID_FEAT_EXT_IBS (1 << 10)
#define CPUID_FEAT_EXT_XOP (1 << 11)
#define CPUID_FEAT_EXT_SKINIT (1 << 12)
#define CPUID_FEAT_EXT_WDT (1 << 13)
#define CPUID_FEAT_EXT_LWP (1 << 15)
#define CPUID_FEAT_EXT_FMA4 (1 << 16)
#define CPUID_FEAT_EXT_TBM (1 << 21)

// ========================================================================
// EXTENDED FEATURE FLAGS - EDX (Function 0x80000001)
// ========================================================================

#define CPUID_FEAT_EXT_SYSCALL (1 << 11)
#define CPUID_FEAT_EXT_XD (1 << 20) // Execute Disable
#define CPUID_FEAT_EXT_1GB_PAGE (1 << 26)
#define CPUID_FEAT_EXT_RDTSCP (1 << 27)
#define CPUID_FEAT_EXT_64BIT (1 << 29) // Long mode (x86-64)

// ========================================================================
// CPU INFO STRUCTURE
// ========================================================================

typedef struct {
  // Vendor string (12 chars + null terminator)
  char vendor[13];

  // Brand string (48 chars + null terminator)
  char brand[49];

  // Basic info
  uint32_t max_basic_cpuid;
  uint32_t max_extended_cpuid;

  // Family, Model, Stepping
  uint32_t family;
  uint32_t model;
  uint32_t stepping;
  uint32_t type;

  // Features from function 0x01
  uint32_t features_ecx;
  uint32_t features_edx;

  // Extended features from function 0x07
  uint32_t extended_features_ebx;
  uint32_t extended_features_ecx;
  uint32_t extended_features_edx;

  // Extended features from function 0x80000001
  uint32_t ext_features_ecx;
  uint32_t ext_features_edx;

  // Cache info
  uint32_t cache_line_size;
  uint32_t cache_count;

  // APIC info
  uint32_t apic_id;
  uint32_t logical_processors;

  // Capabilities (derived from features)
  struct {
    bool has_fpu;
    bool has_tsc;
    bool has_msr;
    bool has_apic;
    bool has_cx8; // CMPXCHG8B
    bool has_sep; // SYSENTER/SYSEXIT
    bool has_cmov;
    bool has_pat;
    bool has_pse36; // 36-bit PSE
    bool has_clflush;
    bool has_mmx;
    bool has_fxsr; // FXSAVE/FXRSTOR
    bool has_sse;
    bool has_sse2;
    bool has_sse3;
    bool has_ssse3;
    bool has_sse4_1;
    bool has_sse4_2;
    bool has_htt; // Hyper-Threading
    bool has_pae; // Physical Address Extension
    bool has_pse; // Page Size Extension
    bool has_pge; // Page Global Enable
    bool has_mtrr;
    bool has_acpi;
    bool has_x2apic;
    bool has_popcnt;
    bool has_aes;
    bool has_avx;
    bool has_avx2;
    bool has_rdrand;
    bool has_rdseed;
    bool has_xsave;
    bool has_osxsave;
    bool has_syscall; // SYSCALL/SYSRET
    bool has_nx;      // Execute Disable
    bool has_1gb_pages;
    bool has_rdtscp;
    bool has_long_mode; // 64-bit support
    bool has_lahf_lm;   // LAHF/SAHF in long mode
    bool has_vmx;       // Intel VT-x
    bool has_svm;       // AMD-V
    bool has_smep;      // Supervisor Mode Execution Protection
    bool has_smap;      // Supervisor Mode Access Prevention
  } caps;

} cpu_info_t;

// ========================================================================
// GLOBAL CPU INFO
// ========================================================================

extern cpu_info_t cpu_info;

// ========================================================================
// FUNCTION PROTOTYPES
// ========================================================================

// Initialize CPU detection
void cpuid_init(void);

// Low-level CPUID instruction wrapper
void cpuid(uint32_t function, uint32_t *eax, uint32_t *ebx, uint32_t *ecx,
           uint32_t *edx);
void cpuid_ex(uint32_t function, uint32_t subfunc, uint32_t *eax, uint32_t *ebx,
              uint32_t *ecx, uint32_t *edx);

// Check if CPUID is supported
bool cpuid_is_supported(void);

// Feature detection helpers
bool cpu_has_feature(uint32_t feature_bit, uint32_t register_id);
const char *cpu_get_vendor(void);
const char *cpu_get_brand(void);

// Print CPU information
void cpuid_print_info(void);
void cpuid_print_features(void);
void cmd_cpuinfo(Terminal *term, const char *args);
void cmd_cpuinfo_detailed(Terminal *term, const char *args);
// Register IDs for cpu_has_feature
#define CPU_REG_ECX 0
#define CPU_REG_EDX 1
#define CPU_REG_EXT_EBX 2
#define CPU_REG_EXT_ECX 3
#define CPU_REG_EXT_EDX 4
#define CPU_REG_EXT81_ECX 5
#define CPU_REG_EXT81_EDX 6

#endif // CPUID_H



================================================================================
FILE: drivers\keyboard_driver.h
================================================================================

#ifndef KEYBOARD_DRIVER_H
#define KEYBOARD_DRIVER_H

#include "../driver_system.h"
#include "../keyboard.h"  // Include keyboard.h for keyboard_layout_t
#include <stdint.h>

#define KEYBOARD_LAYOUT_MAGIC 0x4B4244  // 'KBD'
#define KEYBOARD_MAX_LAYOUTS 8

// Keyboard driver private data
typedef struct keyboard_driver_data {
    keyboard_layout_t *current_layout;
    keyboard_layout_t *default_layout;
    keyboard_layout_t **available_layouts;
    uint32_t layout_count;
    uint8_t max_layouts;
} keyboard_driver_data_t;

// Keyboard driver IOCTL commands
#define KBD_IOCTL_SET_LAYOUT     0x1001
#define KBD_IOCTL_GET_LAYOUT     0x1002
#define KBD_IOCTL_LIST_LAYOUTS   0x1003
#define KBD_IOCTL_LOAD_LAYOUT    0x1004

// IOCTL argument structures
typedef struct {
    char layout_name[32];
} kbd_ioctl_set_layout_t;

typedef struct {
    char layout_name[32];
    char filename[256];
} kbd_ioctl_load_layout_t;

typedef struct {
    uint32_t max_layouts;
    uint32_t layout_count;
    char layout_names[][32];  // Variable length array
} kbd_ioctl_list_layouts_t;

// Public functions
int keyboard_driver_register_type(void);
driver_instance_t *keyboard_driver_create(const char *name);

// Layout management functions (used via IOCTL)
int keyboard_driver_set_layout(driver_instance_t *drv, const char *layout_name);
keyboard_layout_t *keyboard_driver_get_current_layout(driver_instance_t *drv);
int keyboard_load_layout_from_data(driver_instance_t *drv, const void *file_data, size_t file_size);

// Scancode mapping function
char keyboard_driver_map_scancode(const keyboard_layout_t *layout, uint8_t scancode, 
                                 uint8_t shift, uint8_t altgr, uint8_t caps_lock);

#endif // KEYBOARD_DRIVER_H


